'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/','title':"User Documentation",'section':"Packit",'content':"Documentation #   About - Key principles of Packit. Onboarding Guide - How to start using Packit. Packit Service - GitHub App that helps you continuously ensure that your project work in Fedora OS. Testing Farm - Guide to Packit\u0026rsquo;s service for running tests. Frequently Asked Questions - Whys, Whats, contacts. Source-git - Source-git concept and how to work with it. Configuration for packit - Configuration file description. Packit CLI - Commands description. Actions - Further customize Packit\u0026rsquo;s behaviour. Generated code in upstream archives - When your release tarballs contain generated code and you need to patch it downstream.  "});index.add({'id':1,'href':'/docs/source-git/work-with-source-git/update-spec/','title':"Update a spec file",'section':"Working with source-git",'content':"Update a spec file #  Changing a spec file is very straightforward:\n Edit the file. Commit the change locally.   Please make sure that your change complies with Fedora Packaging Guidelines if you intend to bring it to the Fedora ecosystem.\n Once that\u0026rsquo;s done, it\u0026rsquo;s a great practice to create a SRPM and build the spec file change locally.\nIf you are planning to pull an upstream fix, you can read more here.\n"});index.add({'id':2,'href':'/docs/about/','title':"About Packit",'section':"User Documentation",'content':"About Packit #  The key principles of packit #    Packit aims to make things easy and right. But if the default behavior is not the right for you, there is still a way around, but may not be that simple. For example you can use actions to replace packit\u0026rsquo;s default behavior with a script of yours.\n  Reuse existing tools and services where it makes sense: don\u0026rsquo;t reinvent the wheel.\n  You can consume packit in two forms:\n Packit tool can run on your laptop and you run commands you want. Packit service reacts to events and performs actions which you defined in your packit.yaml.    We don\u0026rsquo;t break backward compatibility just like that.\n  Packit has a deprecation policy:\n We can mark a behaviour as deprecated. Deprecated content can be removed or changed after at least 3 minor releases. Deprecated content is advertised in our changelog, printed in the terminal or tracked in your issue tracker.    We care about artifacts which Fedora supports: at the moment it\u0026rsquo;s RPMs, modules and container images.\n Our initial focus is solely on RPMs.    Packit respects Fedora guidelines.\n  We want the latest content in Fedora Rawhide, but only if it works (the new content can be built and tests are passing).\n  Any task done by the automation system must be able to be performed by a human when that is required. Packit service must be capable of recovering from such situation.\n  Packit developers must be able to iterate on all parts packit (testing a change, merging a change, deploying to production) at a pace of at least every two weeks. To accomplish this, the release and validation processes are completely automated.\n  All tests are passing in CI systems for the main branches for all our projects. No excuses.\n  Contributions to packit must be possible by any developer, maintainer, tester, or other engineer. Any Fedora developer or tester should be able to reproduce a bot locally on their machine, given appropriate credentials.\n  Why packit? #    Our intent is to bring downstream and upstream communities closer: provide feedback from downstream to upstream. (e.g. \u0026ldquo;Hello \u0026lt;upstream project Y\u0026gt;, your newest release doesn\u0026rsquo;t work in Fedora Rawhide, it breaks \u0026lt;Z\u0026gt;, here is a link to logs.\u0026quot;)\n  We want to only merge, build and compose components which integrate well with the rest of the operating system. The biggest impact of such behavior will be on Fedora Rawhide and when working on a new Fedora release.\n  Automatically pull and validate new upstream releases. This can be a trivial thing to do, why should maintainers waste their times on work which can be automated.\n  Developing in dist-git is cumbersome. Editing patch files and moving tarballs around is not fun. Why not work with the source code itself? With source-git, you\u0026rsquo;ll have upstream git history and the dist-git content combined in a single repository.\n  Let\u0026rsquo;s use modern development techniques such as pull requests, code review, modern git forges, automation and continuous integration. We have computers to do all the mundane tasks. Why should we, as humans, do such work?\n  We want dist-git to be \u0026ldquo;a database of content in a release\u0026rdquo; rather a place to do actual work. On the other hand, you\u0026rsquo;ll still be able to interact with dist-git the same way. We are not taking that away. Source-git is meant to be the modern, better alternative.\n  DevConf.cz \u0026ldquo;Auto-maintain your package\u0026rdquo; talk.\n"});index.add({'id':3,'href':'/development-docs/creating-stream-9-repos/','title':"Creating CentOS Stream 9 source-git repositories",'section':"Development Documentation",'content':"Creating CentOS Stream 9 source-git repositories #  Source-git repos for CentOS Stream 9 are stored as separate repositories in https://gitlab.com/redhat/centos-stream/src in c9s branches.\nHere is how the repositories should be set up:\n  They are open to the public (for contributions).\n  Issues are disabled (BZ is the official bug tracker).\n  Merge requests are enabled.\n  Description is set:\nSource repo for CentOS Stream package $package. You can contribute here by following https://wiki.centos.org/Contribute/CentOSStream/   c9s branch is protected, though force-pushes are allowed from maintainers (for sake of rebasing).\n  How to create such repo #  using packit source-git init\nPushing the repository to GitLab #  We have an identity, centos-stream-packit, which has permissions to create new repositories in the namespace.\nHere comes a sample script utilizing ogr and python-gitlab to create a new repo to satisfy the requirements above:\nimport ogr import os TARGET_GROUP = \u0026quot;redhat/centos-stream/src\u0026quot; GITLAB_TOKEN = os.getenv(\u0026quot;GITLAB_TOKEN\u0026quot;) gitlab_service = ogr.GitlabService(GITLAB_TOKEN) target_group = gitlab_service.gitlab_instance.groups.get(TARGET_GROUP) repo_name = \u0026quot;edk2\u0026quot; project = gitlab_service.gitlab_instance.projects.create({ \u0026quot;name\u0026quot;: repo_name, \u0026quot;namespace_id\u0026quot;: target_group.id, \u0026quot;description\u0026quot;: ( f\u0026quot;Source repo for CentOS Stream package \\\u0026quot;{repo_name}\\\u0026quot;. \u0026quot; \u0026quot;You can contribute here by following https://wiki.centos.org/Contribute/CentOSStream/\u0026quot; ), \u0026quot;issues_enabled\u0026quot;: False, \u0026quot;visibility\u0026quot;: \u0026quot;public\u0026quot;, }) project.protectedbranches.create( {\u0026quot;name\u0026quot;: \u0026quot;c9s\u0026quot;, \u0026quot;push_access_level\u0026quot;: \u0026quot;40\u0026quot;, \u0026quot;merge_access_level\u0026quot;: \u0026quot;40\u0026quot;} ) "});index.add({'id':4,'href':'/docs/cli/source-git/init/','title':"init",'section':"source-git",'content':"source-git init #  Initialize a repository to serve as a source-git repo.\nThe biggest advantage of this command is the functionality to create source-git repos. Here\u0026rsquo;s a quick rundown what packit does:\n  Pull upstream git history (the default is not pull and use the checked out branch).\n  Fetches specfile and additional sources from Fedora or CentOS dist-git.\n  Apply downstream patches as commits.\n  Add packit config file.\n  We have a guide on how to create source-git repos manually if you want to learn more.\nPrerequisites #   Git repo in the current working directory.  Tutorial #  As an example, let\u0026rsquo;s create a source-git repo out of tmux.\nFirst step is to clone the upstream repo:\n$ git clone https://github.com/tmux/tmux $ cd tmux  Now we can run the init command and get our source-git repo:\n$ packit init --fedora-package tmux  With the --fedora-package option we are telling packit to get downstream packaging files from Fedora dist-git.\nYes, it was that simple.\nOnce the command finished successfully, we can create a SRPM and build it in mock to prove the source-git repo works:\n$ packit srpm SRPM: /home/tt/g/packit/packit.dev/tmux/tmux-3.1c-2.g17785c78.fc33.src.rpm $ mock --rebuild -r fedora-rawhide-x86_64 ./*.src.rpm ... Wrote: /builddir/build/RPMS/tmux-3.1c-2.g17785c78.fc34.x86_64.rpm Wrote: /builddir/build/RPMS/tmux-debugsource-3.1c-2.g17785c78.fc34.x86_64.rpm Wrote: /builddir/build/RPMS/tmux-debuginfo-3.1c-2.g17785c78.fc34.x86_64.rpm ... INFO: Done(./tmux-3.1c-2.g17785c78.fc33.src.rpm) Config(fedora-rawhide-x86_64) 1 minutes 0 seconds  If you want to learn more about working with source-git repos, there is a dedicated section in our documentation.\nHelp #  $ packit source-git init --help Usage: packit-dev source-git init [OPTIONS] [PATH_OR_URL] Initialize a source-git repository To learn more about source-git, please check https://packit.dev/docs/source-git/ Options: --upstream-url TEXT URL or local path to the upstream project; defaults to current git repository --upstream-ref TEXT Use this upstream git ref as a base for your source- git repo; defaults to current tip of the git repository --fedora-package TEXT Pick spec file from this Fedora Linux package; implies creating a source-git repo --centos-package TEXT Pick spec file from this CentOS Linux or CentOS Stream package; implies creating a source-git repo --dist-git-branch TEXT Get spec file from this downstream branch, for Fedora this defaults to main, for CentOS it's c9s. When --dist-git-path is set, the default is the branch which is already checked out. --dist-git-path TEXT Path to the dist-git repo to use. If this is defined, --fedora-package and --centos-package are ignored. -h, --help Show this message and exit.  "});index.add({'id':5,'href':'/posts/','title':"Blog Posts",'section':"Packit",'content':"Blog Posts #   March 2021 February 2021 January 2021 December 2020 November 2020 October 2020 Fedora ELN September 2020 August 2020 July 2020 June 2020 May 2020 April 2020 March 2020 February 2020 January 2020 2019  "});index.add({'id':6,'href':'/docs/source-git/work-with-source-git/pull-upstream-fixes/','title':"Pull fixes from the upstream",'section':"Working with source-git",'content':"Pull fixes from the upstream #  One of the common tasks of being a downstream maintainer is to pull fixes from the upstream codebase. This usually happens when a problem is discovered downstream which is already resolved in the upstream code. There are two scenarios how to obtain the upstream code:\n The fix is not released yet by the upstream - this implies pulling the fix from the main development upstream branch. If the fix is already released, one can either update to that upstream release or only pull commits with the fix. Please consult Fedora Update Policy  if you are unsure how to proceed.  Adding changes #  Since your source-git repository shares git history with upstream, you can easily cherry-pick commits which you want to have in the downstream and Packit is then able to turn those commits into patch files with the ability to configure the whole process.\nAs an example, let\u0026rsquo;s try to do this with systemd, in the example below we\u0026rsquo;d be using https://gitlab.com/packit-service/src/systemd. The remote mimics how fedpkg fork works.\n$ git remote -v origin git@gitlab.com:packit-service/src/systemd.git (push) ttomecek git@gitlab.com:TomasTomecek/systemd-stable.git (push) upstream git@github.com:systemd/systemd-stable.git (push)  We have 3 remotes in the repo:\n origin — the official source-git repo where the downstream maintenance happens ttomecek — a fork of the source-git repo upstream — the official upstream repository  With this setup, we can fetch ref from the upstream remote, cherry-pick commits of our choice, push them to the fork ttomecek and open a merge request against the repository referenced as the origin remote.\nControlling the patch process #  Packit recognizes that the upstream commits are meant to be downstream patches:\n Packit generates patch files from the commits via git format-patch. It also adds them into the spec file as new PatchXYZ entries.  If that doesn\u0026rsquo;t work for you, you can tailor the patch process. The main downside is that with the default process you cannot name the patch file nor control where exactly should Packit place the Patch123: 123.patch line in the spec file. There is a way though how you can do all of that yourself. You can set patch metadata in a commit message which Packit will then read and take into account:\n patch_name — name of the patch (e.g. patch_name: my-fancy.patch) present_in_specfile — when set to true, it indicates the patch is set in the spec file so Packit should not do any changes in the spec file (the default is false which will make Packit to define the patch in the spec file)  There are more patch metadata attributes and they are documented in our internal documentation for sake of not making this document too complex.\nPackit parses the metadata as yaml, hence the colon syntax.\nExample:\nAuthor: Packit \u0026lt;packit\u0026gt; AuthorDate: Wed Aug 19 11:55:14 2020 +0000 Commit: Packit \u0026lt;packit\u0026gt; CommitDate: Wed Aug 19 11:55:14 2020 +0000 Apply patch drpm-0.3.0-workaround-ppc64le-gcc.patch patch_name: drpm-0.3.0-workaround-ppc64le-gcc.patch present_in_specfile: true --- src/CMakeLists.txt | 2 +- test/CMakeLists.txt | 12 +----------- 2 files changed, 2 insertions(+), 12 deletions(-)  And this is how a corresponding spec file looks (shortened for brevity)\nName: drpm Version: 0.4.1 Release: 2.g959639c5%{?dist} URL: https://github.com/rpm-software-management/%{name} Source: %{url}/releases/download/%{version}/%{name}-%{version}.tar.bz2 # add workaround for gcc7 on ppc64le temporary before it's fixed in gcc # https://bugzilla.redhat.com/show_bug.cgi?id=1420350 Patch1: drpm-0.3.0-workaround-ppc64le-gcc.patch %prep %autosetup -p1  "});index.add({'id':7,'href':'/docs/source-git/how-to-source-git/','title':"Create source-git repo",'section':"Source-git",'content':"How to create a source-git repository? #  This guide walks through the steps to create a source-git repository from an upstream project.\nPlease bear in mind, that the structure of source-git repositories is still being discussed and in development. Due to this, this guide is subject to change. Consider joining the Fedora Source-git SIG if you are interested and would like to participate in the discussions.\nThe process to construct a source-git repository and a branch to track downstream (distribution) work, which then can be synced to dist-git has the following steps:\n Identify the upstream Git repository and Git commit corresponding to the current version of the software, as available in the distribution. Create and populate a .distro subdirectory in the upstream working tree to hold the files needed to package and test the software in the distribution. Configure syncing to dist-git in .distro/source-git.yaml. Remove the references to the downstream (distribution) patches from the spec-file and apply these patches as Git-commits. Test the source-git repository by trying to sync the content to the corresponding dist-git repository.  As an example, let\u0026rsquo;s see the steps one would need to take to create a source-git repository for acl and a branch to track distribution work in Fedora Rawhide.\nIdentify the upstream Git repository and version #  Let\u0026rsquo;s search for an official project URL for acl in the spec-file for Fedora Rawhide. This could be done by using the web interface for src.fedoraproject.org, too, but as the dist-git repository is needed later on, it makes sense to clone it using fedpkg:\n$ mkdir rpms $ fedpkg clone -a acl rpms/acl Cloning into 'rpms/acl'... remote: Enumerating objects: 699, done. remote: Counting objects: 100% (699/699), done. remote: Compressing objects: 100% (473/473), done. remote: Total 699 (delta 359), reused 442 (delta 207), pack-reused 0 Receiving objects: 100% (699/699), 129.66 KiB | 316.00 KiB/s, done. Resolving deltas: 100% (359/359), done. $ git -C rpms/acl status On branch rawhide Your branch is up to date with 'origin/rawhide'. nothing to commit, working tree clean  The dist-git repo is cloned in an rpms directory, and the corresponding source-git repository will be created in a src directory later on. This directory structure helps to keep multiple dist-git and source-git repositories separate and nicely organized.\nThe URL tag in the spec-file tells, that acl is hosted at https://savannah.nongnu.org/projects/acl. Following the links from that page we can look up the URL of the project\u0026rsquo;s Git repository, and use the https one to clone it:\n$ mkdir src $ git clone https://git.savannah.gnu.org/git/acl.git src/acl Cloning into 'src/acl'... remote: Counting objects: 3687, done. remote: Compressing objects: 100% (962/962), done. remote: Total 3687 (delta 2705), reused 3687 (delta 2705) Receiving objects: 100% (3687/3687), 707.18 KiB | 1.22 MiB/s, done. Resolving deltas: 100% (2705/2705), done. $ git -C src/acl status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean  From the version field of the spec-file we can tell that Fedora Rawhide has acl version 2.3.1. We search the upstream Git repository for the tag which points to the commit corresponding to this version. This commit is going to be the starting point of the rawhide branch on which the distribution work in Fedora Rawhide is going to be tracked.\n$ cd src/acl $ git tag --list | grep 2.3.1 v2.3.1 $ git checkout -B rawhide v2.3.1 Switched to a new branch 'rawhide'  Create and populate the .distro subdirectory #  In source-git, files required to package and test the software in a distribution are stored in a .distro subdirectory. This allows keeping these files separate from the source code. The distribution agnostic name was chosen in order to enable the easy sharing of the packaging work between different distributions.\nLet\u0026rsquo;s create and populate this directory:\n$ mkdir .distro $ rsync --archive --delete \\ --filter 'exclude *.patch' \\ --filter 'exclude sources' \\ --filter 'exclude .git*' \\ ../../rpms/acl/ .distro/ $ tree -a .distro/ .distro/ ├── acl-2.3.1.tar.gz.sig ├── acl.spec └── tests ├── cmd-line-options │ ├── Makefile │ ├── PURPOSE │ ├── runtest.sh │ └── test-core.sh └── tests.yml 2 directories, 7 files  A quick explanation of the filters used in the rsync-command above:\n Patch-files are not copied from dist-git. They will become part of the source-git repository as Git commits at a later step. The sources file, used in dist-git to reference the source-archives in the lookaside-cache is excluded. Upstream sources are part of the working tree in source-git. The .git directory of the dist-git repo, and other .git* files are excluded. These are specific to the dist-git repository. They are re-created later on, as needed, using a content specific to source-git.  As gitignore rules in the upstream repo and dist-git might be different, we need to reset these for the .distro directory. In the case of acl for example the top-level .gitignore has a rule to exclude Makefiles, but the tests in dist-git have a Makefile, which need to become part of the source-git repo.\nBecause the .gitignore file in dist-git has no other ignore rules than the one for the source-code archives, there are no other rules to be added to .distro/.gitignore.\n$ cat \u0026gt; .distro/.gitignore # Reset gitignore rules !*  Configure syncing to dist-git #  Now, let\u0026rsquo;s create the configuration which is going to be used when syncing content to dist-git. This is used to control certain aspects of syncing content to dist-git when using packit update-dist-git.\nCreate a file called .distro/source-git.yaml with the following content:\n--- downstream_package_name: acl upstream_ref: v2.3.1 patch_generation_ignore_paths: - .distro/ patch_generation_patch_id_digits: 0 sync_changelog: true synced_files: - src: .distro/ dest: . delete: true filters: - \u0026#34;protect .git*\u0026#34; - \u0026#34;protect sources\u0026#34; - \u0026#34;exclude source-git.yaml\u0026#34; - \u0026#34;exclude .gitignore\u0026#34; downstream_package_name tells packit the name of the package.\nupstream_ref is the Git ref to be used to tell where upstream history ends and downstream history starts. Packit uses this value to tell which version of the source-archive to download from the URL specified in Source, in order to be uploaded to dist-git\u0026rsquo;s lookaside-cache.\npatch_generation_ignore_paths lists the paths which should be ignored when generating downstream patches, to be added in dist-git. As .distro is the place where the files related to packaging are stored, set the configuration to ignore this path, so that there are no patch files generated for it.\npatch_generation_patch_id_digits tells Packit how many digits are used, at minimum, when adding PatchN tags to the spec-file. The patch in acl is in the form of Patch1, doesn\u0026rsquo;t have a minimum width, so set this value to 0.\nSetting sync_changelog to true tells Packit to sync the changelog in the spec-file as is. This disables Packit\u0026rsquo;s functionality to automatically update the changelog when syncing to dist-git.\nsynced_files controls the way files are synced when updating dist-git. In the context of the current source-git structure this means to syncing the content of .distro with the root of the dist-git repo. This is what the src and dest fields configure.\ndelete: true causes files not in src to be deleted from dest.\nfilters is a list of rsync filters to be used to protect paths in dest and exclude paths in src from the sync operation.\nYou can think about the synced_files section as describing the reverse of the rsync-command used to copy content from dist-git to .distro.\nWe plan to make most of this configuration implicit, so most of it might not be required in the future.\nUpdate the spec-file and apply the downstream patches #  In dist-git downstream changes are stored as patch-files, which then are referenced in the spec-file and applied during %prep when building the package. In source-git we want the same changes to become Git commits in the repository. This also means, that it would be semantically weird to reference the patch-files in the spec-file. As there are no patch-files in the source-git repo.\nSo let\u0026rsquo;s remove the following lines from .distro/acl.spec:\n# avoid permission denied problem with LD_PRELOAD in the test-suite Patch1: 0001-acl-2.2.53-test-runwrapper.patch Pay attention not to modify any other part of the spec-file, except deleting these lines. Saving .distro/acl.spec with an editor which is configured to strip white-space from the end of lines will result in unnecessary diff-chunks when syncing content back to dist-git.\nNote, that acl is using %autosetup to apply the patches in %prep, this is why the %prep section doesn\u0026rsquo;t need an update. Because packit update-dist-git doesn\u0026rsquo;t support adding the %patch macros when adding patches to the spec-file during syncing, currently only packages using %autosetup are supported. At the time of writing, adding support for %setup is still not decided.\nAt this point, the .distro directory is ready, and can be commited as the first commit on the rawhide branch.\n$ git add .distro/ $ git commit -m'Initialize as a source-git repository' [rawhide c333206] Initialize as a source-git repository 9 files changed, 736 insertions(+) create mode 100644 .distro/.gitignore create mode 100644 .distro/acl-2.3.1.tar.gz.sig create mode 100644 .distro/acl.spec create mode 100644 .distro/source-git.yaml create mode 100644 .distro/tests/cmd-line-options/Makefile create mode 100644 .distro/tests/cmd-line-options/PURPOSE create mode 100755 .distro/tests/cmd-line-options/runtest.sh create mode 100755 .distro/tests/cmd-line-options/test-core.sh create mode 100644 .distro/tests/tests.yml  The rawhide branch in the source-git repo has its first downstream commit now:\n$ git log --oneline v2.3.1.. c333206 (HEAD -\u0026gt; rawhide) Initialize as a source-git repository  Now, apply the only downstream patch from dist-git. We\u0026rsquo;re using git am in this case, but depending on the type of the patch-files in dist-git, you might need to use git apply:\n$ git am ../../rpms/acl/0001-acl-2.2.53-test-runwrapper.patch  The rawhide branch now also has the downstream change in the source-code as a commit:\n$ git log --oneline v2.3.1.. 7054794 (HEAD -\u0026gt; rawhide) test/runwrapper: copy the preloaded library c333206 Initialize as a source-git repository  The only thing left to do is to make sure that the patch-file generated from this commit is going to keep its name (and not use the default name generated by git format-patch), and that the patch status line is going to be included above the patch when it\u0026rsquo;s added back to the spec-file while syncing to dist-git.\nPackit understands a few metadata fields which can be included in the commit message, and used to tweak how patch-files are generated and included in the spec-file. You can include the patch status with the help of the description field, and specify the patch-file name with patch_name.\nAmend the last commit\u0026hellip;\n$ git commit --amend  \u0026hellip;and edit the commit message to include this field at the end of it.\ntest/runwrapper: copy the preloaded library ... to a temporary directory because the original location might not be accessible by other users. patch_name: 0001-acl-2.2.53-test-runwrapper.patch description: |- avoid permission denied problem with LD_PRELOAD in the test-suite # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Author: Kamil Dudka \u0026lt;kdudka@redhat.com\u0026gt; # Date: Tue Jul 3 10:46:58 2018 +0200 # # On branch rawhide # Changes to be committed: #\tmodified: test/runwrapper # Save and exit.\nTest the source-git repository #  The following requires Packit version 0.31.0 or higher, which at the time of writing this is not yet release. Alternatively you can install the latest development version from Copr.\nTry creating an update in the dist-git repository from the source-git repository you\u0026rsquo;ve just created. All the changes below are local.\n$ cd ../../ $ packit --config src/acl/.distro/source-git.yaml update-dist-git --pkg-tool fedpkg src/acl rpms/acl 2021-05-21 17:19:49.158 api.py INFO Won't be doing kinit, no credentials provided. 2021-05-21 15:19:50.103 distgit.py INFO Archive 'acl-2.3.1.tar.gz' found in lookaside cache (skipping upload).  Now check the dist-git repo to see if there are any changes:\n$ git -C rpms/acl status On branch rawhide Your branch is up to date with 'origin/rawhide'. nothing to commit, working tree clean  A clean working tree in this case means, that the transformation of source-git to dist-git resulted in the same content. Which is good.\nTry adding a new, dummy, change in source-git and update dist-git again, to see a new patch being added:\n$ cd src/acl $ echo 'A dummy change' \u0026gt;\u0026gt; README $ git diff diff --git a/README b/README index abcfdc6..05c4af6 100644 --- a/README +++ b/README @@ -11,3 +11,4 @@ information and references to other related manual pages. For more information on the build process, please refer to doc/PORTING. +A dummy change $ git commit -aF- (reading log message from standard input) Add a dummy change description: a patch to try things out [rawhide fb34af6] Add a dummy change 1 file changed, 1 insertion(+) $ cd ../../ $ packit --config src/acl/.distro/source-git.yaml update-dist-git --pkg-tool fedpkg src/acl rpms/acl 2021-05-27 16:46:38.574 api.py INFO Won't be doing kinit, no credentials provided. 2021-05-27 14:46:39.747 distgit.py INFO Archive 'acl-2.3.1.tar.gz' found in lookaside cache (skipping upload).  Check the diff in dist-git and the new patch generated from source-git:\n$ git -C rpms/acl diff diff --git a/acl.spec b/acl.spec index 2bf7182..ac7bc75 100644 --- a/acl.spec +++ b/acl.spec @@ -15,6 +15,9 @@ Source: https://download-mirror.savannah.gnu.org/releases/acl/acl-%{version}.tar # avoid permission denied problem with LD_PRELOAD in the test-suite Patch1: 0001-acl-2.2.53-test-runwrapper.patch +# a patch to try things out +Patch2: 0002-Add-a-dummy-change.patch + License: GPLv2+ URL: https://savannah.nongnu.org/projects/acl $ cat rpms/acl/0002-Add-a-dummy-change.patch From fb34af687e2b650920775647a7c8d149c60403eb Mon Sep 17 00:00:00 2001 From: =?UTF-8?q?Hunor=20Csomort=C3=A1ni?= \u0026lt;csomh@redhat.com\u0026gt; Date: Thu, 27 May 2021 16:42:19 +0200 Subject: [PATCH 2/2] Add a dummy change description: a patch to try things out --- README | 1 + 1 file changed, 1 insertion(+) diff --git a/README b/README index abcfdc6..05c4af6 100644 --- a/README +++ b/README @@ -11,3 +11,4 @@ information and references to other related manual pages. For more information on the build process, please refer to doc/PORTING. +A dummy change -- 2.31.1  "});index.add({'id':8,'href':'/docs/guide/','title':"Onboarding Guide",'section':"User Documentation",'content':"Onboarding Guide #  Agenda #  We have split the on-boarding process into multiple stages:\n Have packit tooling installed locally. RPM builds pass on your laptop. You are approved to use Packit Service. The project has successful builds inside the service. Packit service handles Fedora Rawhide updates for you.  We welcome all kinds of suggestions to this guide, feel free to open a new issue here.\nHave packit tooling installed locally #  In order to start using packit, we suggest you install the tooling locally. All the logic is baked inside the packit command - so once packit srpm (the command to create a source RPM locally from the current snapshot of the project) starts passing for you, it should work inside packit service as well.\nFedora Linux #  $ sudo dnf install packit  Red Hat Enterprise Linux or CentOS Stream 8 #  On RHEL/CentOS 8 you can install RPM from EPEL repository. On CentOS, some dependencies are in PowerTools repository, so you have to enable it:\n$ sudo dnf install dnf-plugins-core epel-release $ sudo dnf config-manager --set-enabled powertools $ sudo dnf install packit  Via Fedora COPR #  You can also help us test the latest development snapshot by installing packit built from the main branch in Copr:\n$ sudo dnf copr enable packit/packit-master $ sudo dnf install packit $ # OR in case you have packit already installed from the Fedora repositories: $ sudo dnf upgrade packit  From PyPI #  We publish packit to PyPI and it\u0026rsquo;s available as packitos project — packit at PyPI is something different.\n$ pip install --user packitos  From Source #  \u0026hellip; or installing it directly from GitHub:\n$ pip install --user git+https://github.com/packit/packit  In a container #  If none of the above work for you, try running it in a container from our Fedora based image. It contains packit installed from main branch, i.e. the same you\u0026rsquo;d get by pip installing from Github.\n$ podman run -ti --rm -v $PWD:/src --security-opt label=disable quay.io/packit/packit bash $ packit Usage: packit [OPTIONS] COMMAND [ARGS]...  RPM builds pass on your laptop. #  Once you install packit locally, it\u0026rsquo;s time to fill .packit.yaml — the configuration file packit is using. Packit can help to fill the initial template by running the init command:\n$ packit init $ cat .packit.yaml  # See the documentation for more information: # https://packit.dev/docs/configuration/ specfile_path: packit.dev.spec # add or remove files that should be synced synced_files: - packit.dev.spec - .packit.yaml # name in upstream package repository/registry (e.g. in PyPI) upstream_package_name: packit.dev # downstream (Fedora) RPM package name downstream_package_name: packit.dev Head on to page configuration to learn more about the config file.\nPackit supports actions and hooks: you can define your own commands which would replace packit\u0026rsquo;s implementation (e.g. get version, or create a tarball) or run specific commands after the upstream repo is cloned. Please read more about actions here: actions.\nPackit needs an RPM spec file to build your package. The spec file does not need to be included in the upstream repo and can be generated on the fly or downloaded (e.g. from Fedora dist-git). Please check out our FAQ to read about some other common questions.\nYou can also read more about the SRPM process in the document dedicated to the srpm command.\nIs your packit srpm finally passing? If not, feel free to reach out to us. If yes, let\u0026rsquo;s proceed to the next level.\nRunning from the dist-git repository #  When you are not allowed or do not want to run packit command from the upstream git repository, you can run commands from the cloned dist-git repository in the same way as you do from upstream. Make sure, that you specify the upstream_project_url in your configuration.\nYou are approved to use Packit Service. #  In order to start using packit service, our GitHub app, you need to install it in your GitHub projects. Then we need to approve you (usually takes only a few hours).\nThe project has successful builds inside the service. #  If a SRPM can be created locally, all should be good in the service as well. That\u0026rsquo;s the theory. In practice, your laptop and packit service sandbox environment are vastly different. One thing which can happen easily is that a command is not available in the sandbox. Also, all the commands are run using an unprivileged user - you can\u0026rsquo;t install anything or perform any privileged operation. In any case, feel free to reach out to us if you are having troubles and we\u0026rsquo;d be glad to help.\nIn order to get RPM builds for every change in your project, you need add a section jobs inside your .packit.yaml and set up a job to do RPM builds for every change in a PR:\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-all fedora-all stands for all currently available Fedora releases.\nJobs are nicely described over here.\nIf you are looking for an inspiration for your .packit.yaml, check packit\u0026rsquo;s config file since we try to use all the latest features.\nPackit service handles Fedora Rawhide updates for you. #  So you already have a jobs section in your config. Let\u0026rsquo;s extend it with another job to push new upstream releases to Fedora rawhide.\njobs: - job: propose_downstream trigger: release metadata: dist_git_branches: - main Pretty clear I\u0026rsquo;d say: when a new upstream release happens, propose it to dist-git main branch: Fedora Rawhide. Packit enables you to decide whether you want to do a direct push or create a pull request. If you want direct pushes, you need to set a global config option create_pr to false:\ncreate_pr: false jobs: - job: propose_downstream trigger: release metadata: dist_git_branches: - main Packit user in Fedora is not a proven packager, so you need to grant packit user the ability to push.\nCreating pull requests is easy. create_pr defaults to true so the config starting this section is good enough.\n"});index.add({'id':9,'href':'/development-docs/patch-metadata/','title':"Source-git patch metadata",'section':"Development Documentation",'content':"Source-git patch metadata #  This article is an extension to the document in the Work with source-git namespace, Pull upstream fixes.\nThe metadata are a way for users and creators of source-git repos to be in control of how packit handles patch files. Users are not meant to set most of these - our tooling does that: dist2src and packit source-git init.\nIdeally maintainers would just commit changes to source-git repos and have %autosetup to apply all the patches during %prep.\nExample of patch metadata in one of commits in systemd source-git for CentOS Stream 8:\n$ git log HEAD commit 38e6b5b3059410530e0d5287de595cbf4574988b (HEAD -\u0026gt; c8s, upstream/c8s) Author: Lennart Poettering \u0026lt;lennart@poettering.net\u0026gt; Date: Mon Feb 4 10:23:43 2019 +0100 pam-systemd: use secure_getenv() rather than getenv() And explain why in a comment. (cherry picked from commit 83d4ab55336ff8a0643c6aa627b31e351a24040a) CVE-2019-3842 Resolves: #1687514 patch_name: 0563-pam-systemd-use-secure_getenv-rather-than-getenv.patch present_in_specfile: true location_in_specfile: 563 squash_commits: true diff --git a/src/login/pam_systemd.c b/src/login/pam_systemd.c ... You can see the patch metadata are stored in the commit message on the last 4 lines.\nMetadata #  The metadata are stored in commit messages and have a key-value format parsed as yaml. The list of keys follows.\npatch_name #  Type: str\nDefault: the default comes from git-format-patch: \u0026ldquo;By default, each output file is numbered sequentially from 1, and uses the first line of the commit message\u0026rdquo;\nContent: file name of the patch\nExample: \u0026ldquo;my-fancy.patch\u0026rdquo;\nPatch file generated from the commit will have this name. This is useful when a patch is already defined in the spec file and we need to make the patch file match that Patch spec file entry.\ndescription #  Type: str\nDefault: empty string\nExample: \u0026ldquo;This patch is cherry-picked from upstream commit ea45faaa and resolves build failures on arm.\u0026rdquo;\nHuman-friendly description of the patch file to be put above the spec file entry.\npresent_in_specfile #  Type: bool\nDefault: false (the default behaviour does not expect the patch is defined in the spec)\nExample: false\nIs the patch present in spec? If yes, then don\u0026rsquo;t create a new entry in the spec file. If no, add it to the spec.\nignore #  Type: bool\nDefault: false\nExample: true\nSkip this git commit when processing patches. This is handy for commits which change files in source-git repos but are not in an archive or are not meant to be utilized in %prep.\nsquash_commits #  Type: bool\nDefault: false\nExample: false\nThis option is meant to be used to support git-am patch applications. git-am enables you to have multiple git commits for a single patch file. When creating source-git repos with packit source-git init, only the last commit of a patch would be annotated with metadata.\nExample:\n40c3a04 (HEAD -\u0026gt; main) patch 3, commit 3 ┃ this is a single patch file 61647c6 patch 3, commit 2 ┃ consisting of 3 commits 89e9eff patch 3, commit 1\\n\\nsquash_commits: true ┣━ because all leading commits are merged into the first patch 8afd939 patch 2, commit 1\\n\\nsquash_commits: true ┣━ a single commit patch 3a2cff0 patch 1, commit 2\\n\\nsquash_commits: true ┣━ commit 1 and commit 2 are part of the first patch b2b8e06 patch 1, commit 1 ┃ d689043 downstream packaging\\n\\nignore: true b677988 (tag: 0.1.0) upstream release 0.1.0 no_prefix #  Type: bool\nDefault: false\nExample: true\nDo not prepend leading a/ or b/ in the patch files. Use this when applying patches with %patch -p1.\nDropped metadata #  location_in_specfile #  This attribute meant to represent ID of the patch within a spec file but it never worked like that so we dropped it completely. The problem was that rpm does not provide such information when applying patches: it provides a number which is an unrelated internal iterator. We are planning to supersede location_in_specfile with patch_id: https://issues.redhat.com/browse/PACKIT-1376\n"});index.add({'id':10,'href':'/docs/source-git/work-with-source-git/build-locally/','title':"Build current checkout locally",'section':"Working with source-git",'content':"Build your current checkout locally #  Once you are comfortable with your local changes, you can build them before pushing them out. Just make sure that all code changes are committed, otherwise Packit won\u0026rsquo;t be able to create patch files out of them.\nWe are going to use Packit to achieve such a thing, so please make sure you have it installed locally.\nThe command to create source RPMs is called srpm and that\u0026rsquo;s how you can create one:\n$ packit srpm SRPM: /home/tt/g/systemd/systemd-stable/systemd-247.1-2.g68d22b32.fc33.src.rpm  Our changes worked! We can try building them, either in our local environment using Packit - this implies that all build dependencies are installed:\n$ packit local-build  \u0026hellip;or in mock:\nmock --rebuild -r fedora-rawhide-x86_64 ./systemd-247.1-2.g68d22b32.fc33.src.rpm  -r allows you to pick a chroot of your choice and these are exactly the same which you can specify for builds in your packit.yaml.\nIf the build is passing locally, it may be time to propose your changes to dist-git.\nHow Packit generates an SRPM from a source-git repo? #  These are the steps:\n Download archive specified in specfile\u0026rsquo;s Source directive. Create patch files from commits on top off upstream_ref where necessary. Bump release in the spec file. Generate new changelog entry in the spec file. Run rpmbuild and set paths so that rpmbuild can find patches, spec files, archive and additional sources.  "});index.add({'id':11,'href':'/docs/source-git/work-with-source-git/propose-to-dist-git/','title':"Propose your source-git content to dist-git",'section':"Working with source-git",'content':"Propose your source-git content to dist-git #  Once your changes are merged into a source-git repo, the final step is to propose those changes to dist-git and get a production build. Alternatively, you can open a dist-git merge request just to trigger the dist-git checks or see how the changes would look in dist-git.\nIf you want to change something in the spec file, this is the right time to bump release, add a %changelog entry or adjust macros. Packit will copy the content of the source-git spec to the dist-git repo.\nUpdate local dist-git checkout #  The first step is to update a local clone of a dist-git repo:\n$ packit source-git update-dist-git $SOURCE_GIT_REPO_PATH $DIST_GIT_REPO_PATH  This command does not push any changes - everything happens only in your local environment. We advise you to inspect the changes done in your dist-git repo before pushing them out to be sure about them.\nIf you are satisfied with the changes, put them in a new branch, push them out and create a merge request:\n$ git switch -C resolve-bz-1234567 $ git push $USER_ID  The premise is that the remote of your fork is named $USER_ID as this is how centpkg fork does it. Once pushed, create the merge request in your browser.\nFrom this point, you should follow the standard dist-git contribution process.\nOur team is working on simplifying this workflow so some steps described above will be automated in future.\n"});index.add({'id':12,'href':'/docs/source-git/work-with-source-git/','title':"Working with source-git",'section':"Source-git",'content':"Working with source-git #  This document is focused on how Packit treats a source-git repo.\nIf you are looking for the design concept of source-git, please read it here.\nThe source-git concept is fairly simple - take an upstream repo and shove downstream content on top of it. Easy right?\nPackit is then able to work with such a repo and:\n  Create SRPMs\n  Sync the state into dist-git\n  And you are able to utilize all features of Packit Service: RPM builds of PRs, tests on those builds, and getting feedback in pull (merge) requests.\n  Example #  Let\u0026rsquo;s have a look at source-git repo for systemd package:\n$ git log --online 67e6197f91 Apply patch 0001-test-path-util-ignore-test-failure.patch 419ec28428 Apply patch 0001-test-path-util-do-not-fail-if-the-fd_is_mount_point-.patch 36d3e907dd Apply patch use-bfq-scheduler.patch 419e249eea add packit.yaml 49615ae7c6 add downstream distribution sources dc057df84c (tag: v247.1) scope: on unified, make sure to unwatch all PIDs once they've been moved to the cgroup scope  We can see 6 commits:\n 67e6197f91 - HEAD commit, a downstream patch 419ec28428 - a downstream patch 36d3e907dd - a downstream patch 419e249eea - a commit with packit.yaml 49615ae7c6 - all the downstream sources: spec file, presets, \u0026hellip; dc057df84c - upstream commit representing the 247.1 release followed by the rest of the upstream history  packit.yaml looks like this:\n$ cat .packit.yaml --- specfile_path: \u0026quot;fedora/systemd.spec\u0026quot; upstream_ref: \u0026quot;v247.1\u0026quot; patch_generation_ignore_paths: [\u0026quot;fedora\u0026quot;]  As you can see, we are telling Packit, that commit tagged as v247.1 should resemble the 247.1 upstream release and the corresponding release tarball which is used during the build process. Commits on top are converted to patch files if they change code. patch-generation-ignore-paths: says that changes to this paths (files, folders) should not be incorporated into patches: fedora/ folder contains all the downstream packaging content.\nRebase or merge? #  A common workflow in the world of open source development is to accept pull or merge requests and have merge commits in the git history. If the PRs are not rebased against the main branch before the merge, the merge commits in the git-history may be heavily intertwined. We are mentioning this because packit works with the recent git history.\nPackit is able to work with a git history where merge commits have parents behind upstream_ref. When it detects such state, packit creates an ephemeral branch with linear history and generates patch files out of it. You can find more details in the pull request where this was developed.\nPicking up latest upstream changes into your downstream source-git repo has multiple solutions and it\u0026rsquo;s up to you to pick the one which suits your workflow best:\n Rebase against the main upstream branch (a.k.a. git pull --rebase upstream main). This solution implies that you are able to perform the force-push operation (e.g. Fedora and CentOS dist-git instances don\u0026rsquo;t allow force-pushes). This solution creates the cleanest git-history though force-pushing is not a best practices for working with a shared git-branch so we suggest to use this only when necessary (e.g. when updating to a new upstream release). Create a new branch for every upstream release. No rebase needed — may require good branch hygiene since the number of branches can skyrocket. This is probably the easiest and most straightforward solution. Merge upstream changes (a.k.a. git merge upstream/main). Does not alter existing git history, yet makes it more complicated. You also need to make sure that downstream code changes (meaning, downstream patches) need to be on top of the upstream_ref git ref so packit can process them correctly.  Common \u0026ldquo;how-tos\u0026rdquo; with source-git #  We have subsections covering common downstream maintainer use cases:\n Updating a spec file Pulling fixes from upstream Building current source-git checkout locally Proposing your source-git content to dist-git  "});index.add({'id':13,'href':'/docs/packit-service/','title':"Packit Service",'section':"User Documentation",'content':"Packit Service #  Helps you continuously ensure that your project works in Fedora Linux or CentOS Stream.\nEasy to use #  Using Packit Service is very straightforward: add one config file to your repository together with the RPM spec file.\nOn Github you also need to install (see below) our Github App, for Gitlab see FAQ.\nPackit Service validates your pull requests by building your software in Fedora OS. Once the builds are done, Packit lets you know how to install the RPMs inside your environment so you can try the changes before merging them.\nOptionally, Packit Service can run tests for the built software (i.e. copr builds) in all current Fedora OS releases via Testing Farm.\nPackit is also available as a CLI tool, so you can always try things locally on your own. Note that testing is not currently supported with the CLI tool.\nIntegrating Packit-as-a-Service into your project or organization from GitHub Marketplace #   Navigate to the \u0026ldquo;Packit-as-a-Service\u0026rdquo; GitHub application. Under \u0026ldquo;Pricing and setup\u0026rdquo;, click \u0026ldquo;Install it for free\u0026rdquo;. Click \u0026ldquo;Complete order and begin installation\u0026rdquo;. Install the \u0026ldquo;Packit-as-a-Service\u0026rdquo; to repositories of your choice.  Once installed, you will see the \u0026ldquo;Packit-as-a-Service\u0026rdquo; GitHub application in your project settings. In the left sidebar, click \u0026ldquo;Integration \u0026amp; services\u0026rdquo; and you will see the application displayed there.\nIn order to continue, please head to the main Packit guide.\nHow to check Packit Service works in your project? #  Currently, Packit Service is able only to build your changes and provide them as RPMs. Once you create a pull request, Packit Service builds the code from the pull request in COPR repository and reports back COPR build status to the pull request.\nAn example of Packit Service pull request:\nHow to re-trigger Packit Service actions in your pull request? #  Packit Service is able to schedule new builds based on a pull request comment:\n/packit copr-build  or the shorter version\n/packit build  So whenever you run into a flake or feel like you want to retrigger, just type that comment into the PR and enjoy some fine, fresh builds.\nThe standard requirements for permissions still apply, so if you see this message\nOnly users with write or admin permissions to the repository can trigger Packit-as-a-Service  it means the author of the pull request does not have commit access to the repository so the build cannot be scheduled. This is a perfect case for maintainers of the repository to post /packit build in the PR to get a build.\nHow to propose a new downstream update? #  Packit Service is able to propose updates of new upstream releases using this comment in an issue:\n/packit propose-downstream  If you want to propose the latest release into Fedora repositories, create an issue and add that comment into this issue and Packit service triggers and pushes it directly into Fedora dist-git repositories.\nIf all jobs (propose_downstream, defined in packit.yaml file, finished successfully, then the issue is automatically closed.\nOnly users with write or admin permissions to the repository can propose a new update.\nAdding tests #  It is also possible to run tests against the freshly built rpms. See the Testing Farm documentation for details.\n"});index.add({'id':14,'href':'/docs/cli/build/','title':"build",'section':"Packit CLI",'content':"build #  Submit a koji build for the selected branch in Fedora dist-git.\nRequirements #   Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial #    Place a config file for packit in the root of your upstream repository.\n  The command below would perform fedpkg build in the Fedora dist-git main branch.\n$ cd my/ustream/project/ $ packit build   Help #  Usage: packit build [OPTIONS] [PATH_OR_URL] Build selected upstream project in Fedora. By default, packit checks out the respective dist-git repository and performs `fedpkg build` for the selected branch. With `--from-upstream`, packit creates a SRPM out of the current checkout and sends it to koji. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Comma separated list of target branches in dist-git to release into. (defaults to repo's default branch) --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --from-upstream Build the project in koji directly from the upstream repository --koji-target TEXT Koji target to build inside (see `koji list- targets`). --scratch Submit a scratch koji build --nowait Don't wait on build -h, --help Show this message and exit.  "});index.add({'id':15,'href':'/docs/cli/init/','title':"init",'section':"Packit CLI",'content':"init #  Initiate a repository to start using packit. By default this command adds .packit.yaml config file to the git repository in the current working directory.\nSee source-git init if you want to initialize a source-git repo.\nHelp #  $ packit init --help Usage: packit init [OPTIONS] [PATH_OR_URL] Create the initial Packit configuration in a repository See 'packit source-git init', if you want to initialize a repository as a source-git repo. Options: -f, --force Reset config to default if already exists. -h, --help Show this message and exit.  "});index.add({'id':16,'href':'/docs/source-git/design/','title':"Source-git design",'section':"Source-git",'content':"Source-git design #  Source git is the place where the manual work is done #  This document serves as a detailed description of source-git. Please bear in mind that some things are a subject to change — the overall design is pretty solid, but details may be tinkered over time.\nAuthors: Stef Walter, Tomas Tomecek\nTL;DR #  Content of source-git repository is equivalent to dist-git, but uses upstream format: source files instead of tarballs, git commits instead of patches.\nYou can host this repository, or the specific git branch, anywhere you want. If you open a pull request, you will receive feedback on the changes:\n Does the package build with the changes? Do all the package tests pass? How about tests of the dependant packages? Are the changes good to be included in Fedora?  The goal of packit is to provide automation and tooling to interact with source-git repositories so you don\u0026rsquo;t have to touch dist-git ever again. Our plan is to center development experience around upstream repositories and source-git.\nUpstream repositories and source-git repositories are pretty much the same thing. Creating source-git only makes sense when the upstream does not accept downstream spec file or adding spec file to such a project doesn\u0026rsquo;t make sense.\nFull description #  Source git becomes the place for creative and interesting work, including aspects of packaging requiring human effort. We allow dist-git to become an auto-maintained location, used for tracking the current state of Fedora, rather than the place where any actual development happens.\nBecause source git is the location for creative work, we can use modern tooling, GitHub, GitLab, Pagure, pull requests, code review, continuous integration and other modern development workflows.\nIn many cases source git can be the upstream project git itself (mostly with projects where downstream maintainer is also the upstream maintainer). In other cases source git can be a fork of upstream git (such as with the Linux kernel).\nWe take cues from projects that already do this. We use the distributed nature of git repositories to overcome obstacles where certain parts of a package (patches, spec, tests) can not (due to embargoes/secrets) or will not (due the upstream project) be included in the upstream source git.\nBots are perfect candidates to perform the mundane tasks of auto-maintaining dist-git. Whenever a bot gets stuck, it can always ask maintainer for help (or the maintainer can perform the action for the bot).\nPremises #  One of the fundamentally useless manual activities when a maintaining a package in Fedora is moving code from one git repository format to another. a) git is distributed b) dist-git content is mostly boilerplate or regurgitated data.\nLinux distributions gain an advantage from having patches incorporated upstream and not carrying them downstream.\nHuman effort should not be focused on repetitive automatible tasks related to churn and moving code around.\nDist-git is used as a store of state for build tools (like koji). Reinventing dist-git itself fundamentally, means reinventing a lot of tooling.\nPrinciples #  Dist-git tracks the inputs for and source state of a package build in Fedora. It is not a place for development. It is the place where integration happens.\nA Dist-git branch may diverge from the stable state of a Fedora release. The stable state is represented by which builds were tagged into the stable compose, not by what is in dist-git.\nAim to do Fedora development of a package in source git. Either directly in upstream or in downstream git forks and branches of the upstream (see the kernel for longest running example of this).\nAny repetitive task, whether repetitive for a single package, or repetitive across packages should be owned by bots auto-maintaining dist-git. Any creative non-automatable human task should be done in source git.\nWe are starting this project open source from the beginning.\nAcceptance Criteria #  In the ideal path, dist-git should be completely automatically “maintained” (already done to varying extents in the kernel, systemd, cockpit, ostree, conu, colin and other packages).\nIt must be trivially possible to opt in and out of auto-maintenance for a given dist-git branch.\nIt should continue to be possible for a human to fix up a dist-git branch, in cases where a task was done incorrectly by a bot. Bots may overwrite such fixups.\nEach auto-maintained dist-git branch tracks a branch in a source git repository. The source git branch should share a common git history with the upstream project branches if maintainer desires such functionality.\nEach time the HEAD of the git source branch changes, a process is started to update dist-git to reflect those changes. This process may also be triggered manually via a tool. If the dist-git is not in an expected state (last commit is not from the bot), the bot should report such divergence.\nOnly the most recent signed commit is a candidate for pulling into dist-git.\nSource code and patches are pulled from source git branch:\n The source code is the git source branch itself. The latest git tag of the git source branch is treated as the release. It must be possible to ignore certain tag patterns. Any commits after that tag in the git source branch are treated as additional patches to be distributed. In order to turn it into an SRPM and include it into dist-git it may be automatically turned into a tarball via an archive command on its latest tag. It must also be possible to use released tarballs from a project if available and necessary for a given dist-git repository, and layer patch files on top in dist-git.  Spec files are pulled from source:\n In the ideal case a spec file is maintained upstream in the same git repository as the source code. This is similar to how many projects have a Dockerfile. When upstream does not accept a spec file, it should be placed as an additional commit in the source git branch, and carried as if it were a patch. To allow trivial revert, review and merge workflows, the release number of the spec file is automatically generated (eg: SuSE and OBS). The release number should be present in the SRPM file name and contents. %changelog in an SRPM is automatically generated from the commits in source git repository. Various techniques may be used to collapse history. Project specific tooling in the source git repo can be used to generate the spec file (eg: as seen today in the kernel). We must provide reference implementation of such script. A spec file can be auto-generated for new packages, and reviewed by a human, who can do FIXUPs.  See: https://github.com/clearlinux/autospec    Tests are pulled from source:\n Components of the operating system have integration and acceptance tests. In the ideal case these are maintained upstream in the given project. They are treated similar to source code. When an upstream does not accept a test, it should be placed as an additional commit in the branch of the git source repository, and carried as if it was a patch. Tests should be wrapped in such a way that anyone can easily (2 commands at most) execute them locally and iterate on them with good velocity. These tests need to pass in order the component to be included in a compose.  After a bot makes a change to dist-git it automatically triggers the koji build.\nThe build in koji is validated that it works with the rest of the operating system packages in that branches compose. If it does it is then tagged into the compose.\nWhen validation fails, feedback goes back to the upstream project. At an absolute minimum the owner of the source git change. But it must be possible to send feedback to a minimal set of Git Forges (GitHub, GitLab, etc.).\nInstead of configuring the bots globally, the bot entry points (configuration) should live in the dist-git repositories (or source-git). The entry points may contain package specific code and variables that can affect the bot implementation for that repository.\nManual activities take place on source git. Humans may be involved in:\n Investigation of build, test, or packaging failures Material changes to spec files Material changes to test wrappers Writing documentation that describe the new changes Changes to packaging and delivery policy  We must get credentials for the bots to perform these activities. We must implement metering in the beginning to prevent bots going wild across the entire dist-git repository.\nAny change to the bots must self-validate by comparing recent bot behavior on recently changed dist-git repositories, and seeing if they have similar behavior.\nSpecifications and Interfaces #  Configuration in dist-git #  In order to automate dist-git and pull from source git, an extensible configuration file would be placed in dist-git (or source-git).\nPlacing this config in a branch in dist-git indicates that that dist-git branch should be auto-maintained. The config may be removed to turn off auto-maintenance. There is one config per auto-maintained branch, e.g. a config in f28 dist-git branch implies the branch is auto-maintained and points to specific source git branch.\nIt should at a minimum support:\n Which source git repository to pull from. Which branch in that source git repository to pull from. Optional: A container to do dist-git population with Defaults to the ‘default’ container (see below) Optional: An expression that describes how to parse tags in source git as versions This can be completely overridden by the container (see below) Eg: v4.9-rc8 -\u0026gt; 4.9 Optional: Which Koji buildroots to build in Defaults to the one decided by fedpkg Optional: GPG key ids considered valid for signing packages.  Source git best practices #  New upstream releases will result in new source-git branches. We can\u0026rsquo;t rebase existing branches since we would lose the provenance.\nThe diagram showcases how upstream releases (git tags) correspond to source git dist-git branches. New releases are automatically detected and proposed as a pull request. Once the packaging is completed, new corresponding branch is created and the new release should land in a continuously development (cont-dev) branch. Please bear in mind, that in order for a pull request to be merged, it needs to pass all the validation. Therefore in order for the 1.1.0 upstream release to land in the 1.1.0 source git branch, all the tests have to pass.\nIt’s up to a maintainer then to cherry-pick which changes should land in a selected downstream dist-git branch.\nPopulation of dist-git #  The actual population of dist-git and source git. Specification of the population process:\n The input, checked out source git will be placed in a known path. The container should process the input and place it to a well known path. The container image can live in any registry. Every maintainer will be able to create a container image to perform the population on their own, given it follows the specification.  After the population process is done, the bot collects the output, performs a commit, signs it and pushes to dist-git.\nThese two population mechanisms (=container images) will be available to maintainers:\n Default: produce an archive out of the source git content. No patch files. Upstream tarball: Take upstream release tarball and lay additional commits as patches on top.  Use case: Cockpit (where tarball very diverged from git)    Signing of source git #  This is a description of the initial proposal to perform signing of commits. Our expectation is that the design will evolve over time.\nThe HEAD commit on the tracked branch in source git, which represents the content to land in dist-git (see above), must be signed. When new commits are pushed to source git, a bot checks signatures used to sign those commits. The signature IDs which are approved to push to dist-git need to be specified in a configuration file placed in dist-git. If the signature ID is not in the configuration file, the commit is not synced and the bot notifies owners of the source git repository.\nWorkflow:\n A new signed commit is pushed to source git. A bot detects the commit, validates that it is signed using an approved signature.  If not, notifies maintainer to resolve the issue.   If the signature is valid, the bot prepares population of dist-git.  It uses the mechanism described in in previous section “Population of dist-git”. Before pushing to dist-git, the bot signs the commit with its own key. The bot also references the respective source git commit(s).   The commit is pushed to dist-git.  Summary: all commits in dist-git, which are curated by a bot, are signed with bot’s key. The commit message then references the commits in source git. All the mentioned commits need to be signed so it’s possible to figure out who authored and approved the work.\n"});index.add({'id':17,'href':'/development-docs/','title':"Development Documentation",'section':"Packit",'content':"Development Documentation #  This is a home to documentation meant for the Packit team. Everyone is welcome to read.\n Creating and pushing CentOS Stream 9 repositories to GitLab. Patch metadata documentation  "});index.add({'id':18,'href':'/docs/testing-farm/','title':"Testing Farm",'section':"User Documentation",'content':"Testing Farm #  Testing Farm is Packit\u0026rsquo;s testing system. It is a containerized service for running tests. Test execution is configured via Flexible Metadata Format, according to the Metadata Specification.\nEnable Testing #  In order to enable test execution simply include tests jobs in the .packit.yaml configuration:\njobs: - job: tests trigger: pull_request metadata: targets: - fedora-all Required metadata:\n targets - You can use fedora-development, fedora-stable, fedora-all or release specific targets such as fedora-34-x86_64. Also centos-7, centos-8 and centos-stream-8. The targets are mapped to Testing Farm\u0026rsquo;s composes when submitting the tests.  Optional metadata:\n fmf_url - Git repository containing the metadata (FMF) tree. Use any format acceptable by the git clone command. fmf_ref - Branch, tag or commit specifying the desired git revision. Defaults to \u0026ldquo;master\u0026rdquo; when fmf_url is specified and fmf_ref is not.  Restart Testing #  The testing will automatically start after an update to the pull request and successful Copr build. To trigger retesting manually (can come handy in case of infrastructure issues for example), you can use the following comment in the pull request:\n/packit test  Creating Tests #  The easiest way to get started is to use the tmt tool which will help you with the setup. Please follow Fedora tmt page.\nMore Examples #  Get inspiration for a quick start from a couple of real-life examples!\nUsing Filters #  Use a custom filter in the discover step in order to choose relevant tests only:\ndiscover: how: fmf filter: \u0026#34;tier: 1\u0026#34; repository: https://src.fedoraproject.org/tests/selinux Prepare Step #  The prepare step can be used to define how test environment should be prepared before testing. Provide one or more paths to ansible playbooks:\nprepare: how: ansible playbooks: - setup/packages.yml Apache Test #  Here is an example of a simple integration test for the web server httpd and curl utility:\n/apache/smoke: execute: script: - dnf -y install httpd curl - systemctl start httpd - echo foo \u0026gt; /var/www/html/index.html - curl http://localhost/ | grep foo Plan /apache/smoke defines only the execute step. Individual shell commands are provided as a list. Testing will fail if any of the commands returns a non-zero exit status.\nSystemd Tests #  Below you can find little bit more interesting example of a systemd test configuration:\n/systemd/smoke: summary: Basic set of quick smoke tests for systemd. discover: how: fmf filter: \u0026#34;tier: 1 \u0026amp; distro: rhel-8\u0026#34; repository: \u0026#34;https://github.com/systemd-rhel/tests\u0026#34; prepare: how: ansible playbooks: [setup/packages.yml] execute: how: beakerlib This plan enables a set of Tier 1 tests from the shared systemd tests repository. The meaning of individual attributes is as follows:\n Summary — an optional but useful attribute describing high-level purpose of the plan. Discover — instructs to fetch tests from given repository and select relevant ones by provided filter. Prepare — specifies which ansible playbook should be applied to prepare environment for testing. Execute — defines that the beakerlib framework should be used for running the tests.  FMF Tests #  Here\u0026rsquo;s a real-life example of tests enabled for the fmf package. There are several plans defined under the plans directory. The smoke plan enables a super basic test checking availability of the fmf command:\nsummary: Just a basic smoke test execute: how: shell script: fmf --help Plan features is used to execute all available beakerlib tests from the fmf repository:\nsummary: Essential command line features discover: how: fmf repository: https://github.com/psss/fmf execute: how: beakerlib It is also possible to select only a subset of available tests. This is demonstrated by the docs plan. Use an fmf filter like tier:1 to select tests for execution. You can also reference a specific feature area instead:\nsummary: Ensure that documentation is present discover: how: fmf repository: https://github.com/psss/fmf filter: coverage:/stories/docs.* execute: how: beakerlib See the stories directory to get some inspiration for organizing stories and requirements.\nRunning linters #  Running linters on your code is easy to setup using Testing Farm and tmt. Linters are tools which you can install from the distribution and they usually just require a path to files which they check. Here is a plan which you can use to run rpmlint on your spec file:\nsummary: Execute rpmlint on the spec file prepare: - name: packages how: install package: - rpmlint execute: script: - rpmlint fedora/python-ogr.spec Testing Farm API #  Packit Service communicates with Testing Farm via its API.\nIssues \u0026amp; RFEs #  If you have found an issue or have an RFE, you can file an issue in nucleus project.\n"});index.add({'id':19,'href':'/docs/faq/','title':"FAQ",'section':"User Documentation",'content':"FAQ #  Can I use the packit service as soon as I install it into my repository? #  Thanks for your interest in Packit Service! In order to start using the service, your repository or namespace needs to be allowed, which is an action to be done by us. Once we put you on the allowlist, we\u0026rsquo;ll get in touch with you. We are now on-boarding Fedora contributors (with a Fedora Account System account).\nCan I use packit service for any GitHub repository? #  Since Packit Service builds your PRs in Fedora COPR build service, by using Packit-as-a-service, your software needs to comply with COPR rules. If any of these points are violated, we\u0026rsquo;ll remove the builds and may put you on a blocklist so you won\u0026rsquo;t be able to use the service again.\nHow can I contact you? #  If you encounter a problem while using packit or Packit Service, please open an upstream issue. In case of any other questions, feel free to contact us:\n #packit on Libera.Chat user-cont-team@redhat.com  Why do I have to maintain .packit.yaml and a spec file upstream? #  We are working on simplifying the .packit.yaml so it\u0026rsquo;s as small as possible. We will also handle all potentially backward incompatible changes of .packit.yaml. Spec file can be downloaded (see specific question below) from Fedora Pagure instead of having it included in the upstream repository.\nBut what are the benefits? #  Packit makes it trivial to run your project as part of an OS. It provides feedback to your project at the time when the changes are being developed so you can fix incompatible code when you are working on it, not when it\u0026rsquo;s already released. When you push commits to a pull request, you\u0026rsquo;ll get RPM build and test results right away.\nWhy Fedora? #  We\u0026rsquo;ve started with Fedora Linux because we work for Red Hat and we ❤ Fedora.\nHow is Packit different from other services? #  Packit connects the existing services (Copr, Pagure, Koji, Bodhi) together.\nCan we use Packit with Gitlab? #  Yes!\nGitLab doesn\u0026rsquo;t have an app functionality and we don\u0026rsquo;t use the Integrations as it doesn\u0026rsquo;t solve authentication. To enable Packit, you need to manually configure a webhook.\nGo to Settings -\u0026gt; Webhooks and add https://prod.packit.dev/api/webhooks/gitlab or https://stg.packit.dev/api/webhooks/gitlab as URL. Select Push events, Comments, Issues events and Merge request events as Triggers. Do not provide Secret token yet and click Add webhook. You should see the created hook at the bottom of the page now. Select Test and for example Merge requests events. At the top of the page appears a red Hook executed successfully but returned HTTP 401 \u0026quot;X-Gitlab-Token not in request.headers\u0026quot;. Wait a bit and check Issues of the project and after a while there should be a new confidential Packit-Service Authentication issue with instructions how to finish the setup.\nHow can I download RPM spec file if it is not part of upstream repository? #  If you do not want to have the RPM spec file in your upstream repository, you can download it in actions section.\nAdd actions section to your packit.yaml configuration file and download the spec file in a hook post_upstream_clone. Packit service has a limited set of commands available so please use wget or curl.\nThe configuration file with downloading the RPM spec file now looks like this:\nspecfile_path: packit.spec synced_files: - packit.spec - .packit.yaml upstream_package_name: packitos downstream_package_name: packit actions: post-upstream-clone: \u0026#34;wget https://src.fedoraproject.org/rpms/packit/raw/main/f/packit.spec -O packit.spec\u0026#34; I have a template of a spec file in my repo: can packit work with it? #  Yes!\nThe solution is, again, actions and hooks. Just render the spec after the upstream repo is cloned:\nspecfile_path: my-project.spec upstream_package_name: my-project-src downstream_package_name: my-project actions: post-upstream-clone: \u0026#34;make generate-spec\u0026#34; Where the \u0026ldquo;generate-spec\u0026rdquo; make target could look like this:\ngenerate-spec: sed -e 's/@@VERSION@@/$(VERSION)/g' my-project.spec.template \u0026gt;my-project.spec  As a practical example, cockpit-podman project is using this functionality.\nCan I use CentOS Stream with packit service? #  Yes, you can! It\u0026rsquo;s very simple, just add centos-stream-8-x86_64 as a target for the copr_build job:\njobs: - job: copr_build trigger: pull_request metadata: targets: - centos-stream-8-x86_64 After adding tests I see error \u0026lsquo;No FMF metadata found.\u0026rsquo; #  If you encounter this error when running tests via Testing Farm, it means you forgot to initialize the metadata tree with fmf init and include the .fmf directory in the pull request. See Testing Farm documentation for more information.\nDoes packit work with rpmautospec? #  Good that you ask. It does, packit works with rpmautospec quite nicely.\nBefore you start, please make sure that you follow latest documentation for rpmautospec.\nrpmautospec utilizes two RPM macros:\n autorel — to populate Release autochangelog — to figure out changelog  If you want your upstream spec file to also work well when rpmautospec-rpm-macros is not installed, set Release to this:\nRelease: %{?autorel}%{!?autorel:1}  This construct uses autorel macro if it\u0026rsquo;s defined, and if it\u0026rsquo;s not, it sets release to 1.\nFor %changelog, you don\u0026rsquo;t need to include the changelog file upstream and you can have it downstream only, which makes sense - changelog is specific to a release.\nHow do I install dependencies for my commands in packit-service? #  We are running all commands, defined by you, in a sandbox which is locked-down. At the moment we don\u0026rsquo;t have any mechanism for you to define the dependencies you need and us making them available for you.\nIn the mean time we are solving these requests one by one, so please reach out to us.\nA command failed in packit-service: how do I reproduce it locally? #  Packit service runs all commands you defined in a sandbox which is a kubernetes pod in a new project. If you need additional packages or binaries present in the sandbox, please let us know.\nIn the meantime, you can pull our production sandbox image and run the command inside. As an example, this is how we were debugging build problems with anaconda:\n  Clone your upstream git repo.\n  Launch the container and bind-mount the upstream project inside:\n  $ docker run -ti --rm --memory 768MB -v $PWD:/src -w /src quay.io/packit/sandcastle:prod bash Run commands of your choice:  [root@4af5dbd9c828 src]# ./configure checking for a BSD-compatible install... /usr/bin/install -c checking whether build environment is sane... yes checking for a thread-safe mkdir -p... /usr/bin/mkdir -p checking for gawk... gawk checking whether make sets $(MAKE)... yes checking whether make supports nested variables... yes checking whether UID '0' is supported by ustar format... yes checking whether GID '0' is supported by ustar format... yes checking how to create a ustar tar archive... gnutar checking whether make supports nested variables... (cached) yes checking whether make supports the include directive... yes (GNU style) checking for gcc... gcc checking whether the C compiler works... yes ... Our deployment is running in OpenShift Online which is using docker as a container engine, that\u0026rsquo;s why we are using docker here and not podman.\nSince OpenShift invokes pods using arbitrary UIDs and as you can see, the command above is invoked as root, it does not match production packit-service. So, if running a local container didn\u0026rsquo;t help you with reproducing the issue, you can try running it in openshift!\nHere is a simple python code how packit-service does it:\nfrom sandcastle import Sandcastle # this should be the path to your local clone of the upstream project git_repo_path: str = \u0026#34;fill-me\u0026#34; # kubernetes namespace to use k8s_namespace: str = \u0026#34;myproject\u0026#34; command = [\u0026#34;your\u0026#34;, \u0026#34;command\u0026#34;, \u0026#34;of\u0026#34;, \u0026#34;choice\u0026#34;] # This is how your code gets copied (via rsync) into the openshift pod m_dir = MappedDir(git_repo_path, \u0026#34;/sandcastle\u0026#34;, with_interim_pvc=True) o = Sandcastle( image_reference=\u0026#34;docker.io/usercont/sandcastle:prod\u0026#34;, k8s_namespace_name=k8s_namespace, mapped_dir=m_dir ) o.run() try: output = o.exec(command=command) print(output) finally: o.delete_pod() This script requires:\n sandcastle installed being logged in an openshift cluster (oc whoami to confirm) rsync binary available  If none of these helped you, please reach out to us and we\u0026rsquo;ll try to help you.\n"});index.add({'id':20,'href':'/docs/cli/create-bodhi-update/','title':"create-bodhi-update",'section':"Packit CLI",'content':"create-bodhi-update #  Create a new bodhi update for the latest Fedora build of the upstream project.\nRequirements #   Upstream git repository on Github. Packit config file placed in the upstream repository. Valid Fedora Kerberos ticket.  Tutorial #    Place a config file for packit in the root of your upstream repository..\n  Once the builds are done, you can run the create-update command. If you don\u0026rsquo;t specify the koji builds packit takes latest build.\n$ packit create-update --dist-git-branch f29 https://github.com/packit/packit.git Bodhi update FEDORA-2019-b72add0dcd: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-b72add0dcd - stable_karma: 3 - unstable_karma: -3 - notes: \u0026quot;New upstream release 0.1.0\u0026quot;   Help #  Usage: packit create-update [OPTIONS] [PATH_OR_URL] Create a bodhi update for the selected upstream project PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Comma separated list of target branches in dist-git to create bodhi update in. (defaults to repo's default branch) --koji-build TEXT Koji build (NVR) to add to the bodhi update (can be specified multiple times) --update-notes TEXT Bodhi update notes --update-type [security|bugfix|enhancement|newpackage] Type of the bodhi update -h, --help Show this message and exit.  "});index.add({'id':21,'href':'/docs/cli/source-git/update-dist-git/','title':"update-dist-git",'section':"source-git",'content':"source-git update-dist-git #  Transform the content from a source-git repository in a dist-git format, and update the corresponding dist-git repository.\nHelp #  $ packit source-git update-dist-git --help Usage: packit-dev source-git update-dist-git [OPTIONS] SOURCE_GIT DIST_GIT Update a dist-git repository using content from a source-git repository Update a dist-git repository with patches created from the commits between \u0026lt;upstream_ref\u0026gt; and the current HEAD of the source-git repo. This command, by default, performs only local operations and uses the content of the source-git and dist-git repository as it is: does not checkout branches or fetches remotes. A commit in dist-git is created only if a commit message is provided with --message or --file. The source archives are retrieved from the upstream URLs specified in the spec-file and uploaded to the lookaside cache in dist-git only if '--pkg- tool' is specified. Examples: To update a dist-git repo from source-git without uploading the source- archive to the lookaside cache and creating a commit with the updates, run: $ packit -c src/curl/.distro/source-git.yaml update-dist-git \\ src/curl rpms/curl To also commit the changes and upload the source-archive to the lookaside- cache specify -m and --pkg-tool: $ packit -c src/curl/.distro/source-git.yaml update-dist-git \\ -m'Update from source-git' --pkg-tool fedpkg \\ src/curl rpms/curl Options: --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). --pkg-tool TEXT Name or path of the packaging tool used to work with sources in the dist-git repo. A variant of 'rpkg'. Skip retrieving and uploading source archives to the lookaside cache if not specified. -m, --message \u0026lt;msg\u0026gt; Commit the changes in the dist-git repository and use \u0026lt;msg\u0026gt; as the commit message. Mutually exclusive with -F. -F, --file \u0026lt;file\u0026gt; Commit the changes in the dist-git repository and take the commit message from \u0026lt;file\u0026gt;. Use - to read from the standard input. -h, --help Show this message and exit.  "});index.add({'id':22,'href':'/docs/source-git/','title':"Source-git",'section':"User Documentation",'content':"Source-git documentation #  We initiated source-git as an alternative to working in dist-git. The need was especially amplified after we realized that many projects already do this. The problem was that everyone created a workflow and tooling for themselves which made it really hard to share knowledge and on-board new projects. Our intention is to create an implementation which is highly configurable, easy to start with and provides both command-line tooling and a service which is tightly integrated with GitHub and GitLab.\n Before you continue reading, we assume you are familiar with the Fedora Maintenance Guide.\n Source-git is a git repository which contains upstream sources and downstream-specific files: for packaging and code changes specific to a distribution, in our case Fedora Linux, CentOS Stream and Red Hat Enterprise Linux.\nThe basic requirement on a source-git repo is that one needs to be able to create an SRPM out of the current checkout. We need several files to achieve such a thing:\n  RPM Spec file\n  Archive with sources\n  Downstream patches to be applied in the spec file\n  Spec file #  We are often being asked a question about spec files: \u0026ldquo;Do we really need to have a spec file in our upstream repo or a source-git repo?!\u0026rdquo; No, you don\u0026rsquo;t, though storing the spec file directly in the repository will save you a lot of trouble - when you disconnect the repository from the build recipe, the spec file:\n Adding or changing a build dependency will require changing the spec file in the other location as well. Someone may change the remote spec file and make builds fail suddenly. Debugging build failures will be a nightmare because you simply can\u0026rsquo;t edit the spec file easily.  Archive #  Packit downloads the archive defined as Source or Source0 in your spec file to produce a SRPM.\nDownstream patch generation process #  The important part of the patch generation process is for Packit to know, from which commit it should start generating patches. The theory here is that you mark a certain commit and it should resemble the content of the archive. All the code changes on top are treated as downstream changes and the respective patch files are generated. The marked commit usually represents a specific upstream release. This means that all the generated patches need to be able to be applied during the build process.\nupstream_ref is this border between upstream commits, usually matching an upstream release tag, and downstream commits. Packit iterates over every git commit sitting on top off upstream_ref.\nPackit distinguishes between 2 types of git commits:\n Those that change code (usually pulled from upstream) - Packit converts these into patch files so they can be applied to the source tree in the %prep section during the build process. Changes to packaging (spec file, other sources, changes to .packit.yaml).  Downstream patches to be applied in the spec file #  In the downstream, it\u0026rsquo;s a common workflow to pick up upstream patches from the main branch, backport them on top of the current version in Fedora, CentOS Stream or RHEL and apply the patches during the build process.\nSource-git is perfect for this because patches are stored as git commits and patch files are generated on the fly.\nThis was just a gentle intro to source-git, for more info you can continue with:\n How to create a source-git repo? Working with source-git Source-git concept  "});index.add({'id':23,'href':'/docs/cli/propose-downstream/','title':"propose-downstream",'section':"Packit CLI",'content':"propose-downstream #  This is a detailed documentation for the update functionality of packit. The command creates a new pull request in Fedora using a selected or latest upstream release.\nRequirements #   Upstream git repository on Github. Upstream release (read, git tag) where version in spec file is equivalent to the name of the git tag. Packit config file placed in the upstream repository. Spec file present in the upstream repository and is correct in a given release. Pagure API tokens for Fedora Dist-git. Github API token. Valid Fedora Kerberos ticket.  Tutorial #    Place a file called .packit.yaml or packit.yaml in the root of your upstream repository.\n The configuration is described in this document. Please get inspired from an existing config.    Place a spec file into your upstream project (and make sure that specfile_path in the config has a correct value).\n This spec file will be then used to perform the update in Fedora. When you create a new upstream release, you should also update the spec file. Once your upstream release is out (and the spec file is really up to date), you can use packit to release it into Fedora.    Create a new upstream release. The spec file needs to be included in the ref for upstream release, because packit checks out the tag for the upstream release before copying files downstream.\n  Once you have performed the upstream release (and the new archive is up), run packit propose-downstream in a working directory of your upstream repository:\n$ git clone https://github.com/user-cont/colin.git $ cd colin $ packit propose-downstream using \u0026quot;master\u0026quot; dist-git branch syncing ./colin.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/c/colin/colin-0.3.0.tar.gz 100%[=============================\u0026gt;] 3.18M eta 00:00:00 downloaded archive: /tmp/tmpaanrpgjz/colin-0.3.0.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/colin/pull-request/4 As you can see, one of the things propose-downstream does is, it downloads the upstream release tarball and uploads it to the lookaside cache. This is required by the Fedora Packaging Guidelines. Then it takes the spec file from the upstream repo, copies it downstream (while also all the files set in the synced_files) and creates the downstream PR.\n  Help #  Usage: packit propose-downstream [OPTIONS] [PATH_OR_URL] [VERSION] Land a new upstream release in Fedora. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory VERSION argument is optional, the latest upstream version will be used by default Options: --dist-git-branch TEXT Comma separated list of target branches in dist-git to release into. (defaults to all branches) --dist-git-path TEXT Path to dist-git repo to work in. Otherwise clone the repo in a temporary directory. --local-content Do not checkout release tag. Use the current state of the repo. This option is set by default for source-git repos --force-new-sources Upload the new sources also when the archive is already in the lookaside cache. --no-pr Do not create a pull request to downstream repository. --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). -f, --force Don't discard changes in the git repo by default, unless this is set. -h, --help Show this message and exit.  "});index.add({'id':24,'href':'/docs/configuration/','title':"Configuration",'section':"User Documentation",'content':"Configuration #  Packit uses a configuration file in the upstream repository. The config file is written in YAML language.\nYou should place the file in the root of your upstream repo. Packit accepts these names:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Both Packit Service and packit tool use this configuration file.\nTop level keys #  specfile_path #  (string) Relative path to a spec file within the upstream repository. If not specified, defaults to:\n downstream_package_name.spec if downstream_package_name is set. Else recursively search the tree and use the first spec file found.  upstream_project_name #  (string) Deprecated since packit-0.7.0, use upstream_package_name instead.\nupstream_package_name #  (string) Name of the upstream repository (e.g. in PyPI), defaults to the name of the Github repository; it\u0026rsquo;s used when working with the upstream project, as a release archive name and as a directory name in that archive.\nupstream_project_url #  (string) URL of the upstream project (e.g. https://github.com/packit/packit).\ncreate_pr #  (bool) When doing a new update in Fedora dist-git, should packit create a new pull request (defaults to true) or push directly to dist-git (if set to false).\nsync_changelog #  (bool) When doing a new update in Fedora dist-git, the specfile changelog is synchronised when set to true. By default (false), everything but the changelog part is synchronized. Use this only when your changelogs are in sync since this overwrites the changelog in the downstream.\nsynced_files #  (list of strings or dicts) A list of relative paths to files in the upstream repo which are meant to be copied to dist-git during an update (spec file path and config file path are set every time by default).\nUnder the hood this will use rsync --archive to synchronise the paths between the upstream and the dist-git repo.\nThe fields for a dictionary item in the list are the following:\n src: A single path or a list of paths in the upstream repo that should be synced to dist-git. dest: Path in the dist-git repo, where paths in src should be synced to. mkpath: Flag to indicate if missing path components in dest should be created or not (default: false). delete: Flag to indicate if extra content from dest should be deleted (default: false). filters: List of rsync filter rules to be used during syncing.  Examples: #  Copy a file from root of the upstream repo to dist-git:\nsynced_files: - packit.spec If you copy packit.yaml downstream, you can then take advantage of sync-from-downstream command:\nsynced_files: - .packit.yaml Rename or change the path of the synced file in dist-git:\nsynced_files: - src: packit.spec dest: redhat/packit.spec Paths also support globs. Copy everything from fedora-packaging folder and put it to the root of the dist-git repo:\nsynced_files: - src: fedora-packaging/* dest: . Sync the entire content of the fedora-packaging directory, and delete extra content found in the root of the dist-git repo; protect .git* files and the sources file from deletion:\nsynced_files: - src: fedora-packaging/ dest: . delete: true filters: - \u0026#34;protect .git*\u0026#34; - \u0026#34;protect sources\u0026#34; Specify multiple source files to copy:\nsynced_files: - src: - package.spec - some-file dest: . Set mkpath to true to create missing path components in dist-git. In the example below, subdir is created if missing.\nsynced_files: - src: some.file dest: subdir/some.file mkpath: true upstream_ref #  (string) Git reference to last upstream git commit (for source-git repos). Can be set to commit hash, tag or a branch name. You can also use globbing pattern to find a tag. In case you want to use globbing pattern for a branch, prefix the pattern with branches/, e.g. for a branch matching *-release set to branches/*-release.\ndownstream_package_name #  (string) Name of the RPM package in Fedora, defaults to the name of the Github repository.\ndist_git_namespace #  (string) Namespace in dist-git URL (defaults to rpms).\ndist_git_base_url #  (string) URL of dist-git server, defaults to https://src.fedoraproject.org/ (has to end with a slash).\ncreate_tarball_command (deprecated) #  Please use create-archive action\ncurrent_version_command (deprecated) #  Please use get-current-version action\nactions #  (string) Custom actions/hooks overwriting the default behavior of packit (more in Actions).\njobs #  (list of dicts) A list of job definitions for packit service: see below for details.\nallowed_gpg_keys #  (list of string) A list of gpg-key fingerprints; if specified, one of the configured keys have to sign the last commit when updating in downstream; add GitHub key (5DE3E0509C47EA3CF04A42D34AEE18F83AFDEB23) if you want to use this on code merged via GitHub web interface.\nspec_source_id #  (int or string) Numeric ID of Source inside spec file which packit should change when setting path to the newly generated tarball, can be also full name of the macro. Defaults to Source0 or Source, whichever is found first in the spec file.\nupstream_tag_template #  (string) Packit by default expects git tags to match versions (e.g. when doing the propose-downstream command) - if you are using a different tagging scheme, let\u0026rsquo;s say v1.2.3 you can then set this parameter to v{version} and packit will fill in the version argument.\narchive_root_dir_template #  (string) In the fix-spec-file action Packit changes first %setup (or %autosetup) macro in %prep and adds -n so the generated tarball can be unpacked. For this purpose, it requires the name of the directory in the source archive. For tar archives with one directory, Packit gets it automatically. If Packit is not able to extract it from the archive with the tar python module, it is possible to specify it explicitly with this option.\nDefault value is {upstream_pkg_name}-{version}.\nYou can use following tags in string:\n {upstream_pkg_name} - name of the upstream package {version} - package version  patch_generation_ignore_paths #  (list of strings) In a source-git repo, when packit is generating patches, it excludes changes to the spec file and packit.yaml by default: with this option you can precisely specify paths to exclude.\npatch_generation_patch_id_digits #  (integer) The number of digits (minimum width) used for patch IDs when adding PatchN tags to a spec-file while updating dist-git from a source-git repository. Defaults to 4, that is, patches will look like PatchNNNN: \u0026lt;patch_name\u0026gt;, and leading zeros are added, if needed. A value of 0 means \u0026ldquo;no minimum width\u0026rdquo;.\nnotifications #  There is only one notification configuration you can set up right now: enable the \u0026ldquo;Congratulations!\u0026rdquo; comment which will packit send after a successful build of a pull request is done.\nThe default behaviour is not to send the comment with instructions how to install a package with the change implemented in the pull request:\nnotifications: pull_request: successful_build: false You can enable the commenting by setting successful_build to true.\ncopy_upstream_release_description #  (bool) When doing a new update in Fedora dist-git, the Github upstream release description is copied to the specfile changelog when set to true. By default (false), commit message titles (first line of a commit message) are copied. e.g.\n copy_upstream_release_description = True:  %changelog * Thu Oct 15 2020 Packit Service \u0026lt;user-cont-team+packit-service@redhat.com\u0026gt; - 0.18.0-1 Packit got new archive_root_dir_template config option to get custom archive root dir. You can find more info in the documentation.  copy_upstream_release_description = False (default):  %changelog * Thu Oct 15 2020 Packit Service \u0026lt;user-cont-team+packit-service@redhat.com\u0026gt; - 0.18.0-1 - Use inner archive directory in %setup macro - Use archive_root_dir_template sources #  (list of dicts) A list of sources to override the URLs of SourceX entries in the spec-file.\nsources: - path: rsync-3.1.3.tar.gz url: https://git.centos.org/sources/rsync/c8s/82e7829c0b3cefbd33c233005341e2073c425629 path is the path relative to the directory with sources where the source will be placed. If a SourceX entry with corresponding basename exists in the spec-file, the source will be downloaded from the url found in the configuration instead of the location defined in the spec-file.\nMinimal sample config #  This is a sample config which is meant for packit itself.\n# packit is named packitos on PyPI b/c packit name was already taken upstream_package_name: packitos Packit-as-a-Service #  As of July 2019, packit service doesn\u0026rsquo;t have any web interface, so the only way to change its behaviour is via the config file you just read about.\nWhen you open a pull request against your upstream repository, packit service picks up configuration file from your pull request, not from the branch against the PR is opened. This way, you can polish your .packit.yaml and see the results right away. (for more info, please see packit-service#48)\nPackit service jobs #  Once the service starts handling events of your repository, it needs to have a clear definition of what it should do.\nThe tasks the packit service should do are defined in section jobs. The section is a list of dicts:\njobs: - {key: value} - {} If there is no jobs section in the configuration file, jobs default to:\njobs: - job: copr_build trigger: pull_request metadata: targets: fedora-stable - job: tests trigger: pull_request metadata: targets: fedora-stable - job: propose_downstream trigger: release metadata: dist_git_branches: - fedora-all If you do not want to use the jobs then the jobs section in the configuration file should be empty:\njobs: [] Every job has two mandatory keys:\n job - name of the job (you can imagine this as a CLI command) trigger - what is the trigger for the job?  Every job only supports a specific set of triggers.\nJobs can also accept additional configuration in a key metadata which has dict as a value:\njobs: - job: some-job trigger: ran-out-of-beer metadata: key: value Overriding global parameters #  You are able to override your global parameters (such as specfile_path, downstream_package_name, actions\u0026hellip;) for every job. This is very useful when you want to set up a build or a test matrix using different parameters or configuration. It\u0026rsquo;s also useful when your release workflow differs between Fedora and EPEL.\nIn order to do such a thing, just set a value you want to override in the respective job.\nExample:\nspecfile_path: package.spec jobs: - job: some-job trigger: ran-out-of-beer metadata: key: value specfile_path: somewhere/else/package.spec In this example, the job some-job would override specfile_path to somewhere/else/package.spec instead of using ./package.spec.\nSupported jobs #  copr_build\nCreate a SRPM and submit an RPM build to Fedora COPR build system.\nSupported triggers:\n pull_request \u0026ndash; check out content of the pull request commit \u0026ndash; reacts to new commits to the specified branch release \u0026ndash; check out content of the tag associated with the release  Required metadata:\n targets - a (list of) mock chroot(s) where the build is going to be executed (example fedora-rawhide-x86_64): for more info see below. branch - the name of the branch we want to build for when using commit trigger  Optional metadata:\n timeout - (seconds) give up watching a build after timeout, defaults to 7200s, i.e. 2 hours owner - a namespace in Copr where the build should happen (defaults to packit) project - a name of the Copr project (defaults to \u0026quot;{github_namespace}-{repository_name}-{pr_id}\u0026quot;) additional_repos - a list of additional buildroot repositories list_on_homepage \u0026ndash; The project will be shown on Copr frontend homepage if set to True. Defaults to False. The value is represented as unlisted_on_hp in Copr project settings. preserve_project \u0026ndash; The project will not be removed after 60 days if set to True. Defaults to False. The value is represented as delete_after_days in Copr project settings (True is -1 and False is 60).  When using a custom owner, Packit Service asks for builder permission the first time it tries to build in the project. In case the configuration of the Copr project (e.g. adding new targets) need to be updated, Packit Service asks for admin permission. You need to approve these requests in the Copr project settings.\nIf you do not want to give us admin permission, you can update the project settings manually in Copr based on the guidance Packit Service gives.\nBoolean values (list_on_homepage and preserve_project) are not updated when you use custom owner.\nExample\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-stable - centos-stream-8-x86_64 With this configuration, you\u0026rsquo;ll get builds in all stable fedora releases (excluding rawhide) and the CentOS stream.\nAvailable COPR build targets #  There are multiple places where you can get the latest list of available build targets:\n  Open your COPR project, then click \u0026ldquo;Settings\u0026rdquo; \u0026gt; \u0026ldquo;Build options\u0026rdquo; \u0026gt; \u0026ldquo;Chroots\u0026rdquo; - these are the same values packit accepts.\n  Install package copr-cli and run:\n  $ copr-cli list-chroots centos-stream-8-aarch64 centos-stream-8-x86_64 custom-1-i386 custom-1-x86_64 epel-6-i386 epel-6-x86_64 epel-7-aarch64 epel-7-x86_64 epel-8-aarch64 epel-8-x86_64 fedora-32-aarch64 fedora-32-armhfp ...   You can use aliases\n fedora-stable — stable versions of Fedora (e.g. Fedora 32 and 33) fedora-development — development versions of Fedora (e.g. Fedora 34 + Rawhide) fedora-all — fedora-stable + fedora-development  By default, the x86_64 architecture will be used, but you you can override the default e.g. fedora-stable-aarch64.\n  production_build (in preview, no reporting yet)\nCreate a SRPM and submit an RPM build to Fedora Koji build system.\nAt the moment it is not possible to run non-scratch production builds from upstream. For more info, please see the following issue. However, it is still possible to run scratch builds.\nSupported triggers:\n pull_request \u0026ndash; check out content of the pull request commit \u0026ndash; reacts to new commits to the specified branch release \u0026ndash; check out content of the tag associated with the release  Required metadata:\n branch \u0026ndash; the name of the branch we want to build for when using commit trigger  Optional metadata:\n targets \u0026ndash; a (list of) targets we want to build for, list of supported targets can be listed using with koji list-targets scratch \u0026ndash; defaults to false, use to create scratch (test) builds instead of the real production builds  propose_downstream\nLand a new upstream release in Fedora. This job only makes sure the changes happen in Fedora dist-git - no builds. The global key create_pr controls whether a pull request is created or changes are pushed directly.\nSupported triggers: release.\nOptional metadata:\n dist_git_branches - a (list of) branch(es) in dist-git where packit should work (defaults to main). You can also use fedora-development, fedora-stable and fedora-all aliases to not need to change the config file when the new system version is released.  Example\njobs: - job: propose_downstream trigger: release - job: propose_downstream trigger: release metadata: dist_git_branches: - f32 This config would update Fedora Rawhide and Fedora 32 dist-git branches.\ntests\nSee more about tests here.\nUser configuration file #  When running packit as a tool locally, it is convenient to use a configuration file to provide data such as API tokens. Packit respects XDG_CONFIG_HOME environment variable. If not set, it looks inside ~/.config/ directory.\nThe acceptable names are the same as for the package config:\n .packit.yaml .packit.yml .packit.json packit.yaml packit.yml packit.json  Values #     Key name Type Description     debug bool enable debug logs   fas_user string username in Fedora account system (to perform kinit if needed)   authentication dict tokens for services (GitHub, Pagure)   upstream_git_remote string name of the git remote to discover upstream project URL from    The authentication is a dictionary where:\n key is a hostname, url or name that can be mapped to a service-type, for example github.com or pagure value is a dictionary with keys: token and instance_url (optional)  e.g.:\nauthentication: github.com: token: mnbvcxz123456 pagure: token: qwertyuiop098765 instance_url: https://src.fedoraproject.org The GitHub token is needed when packit interacts with Github API, get it at https://github.com/settings/tokens (getting full read \u0026amp; write repo scope should be enough). The Pagure token needed to access REST API, get it at https://src.fedoraproject.org/settings#nav-api-tab\nSpecifying tokens as direct keys github_token and pagure_user_token has been deprecated and will be removed in future versions.\nSince API tokens are a very sensitive information, please do NOT ever store them in a public (such as a GitHub repository). The configuration file here is located on your workstation, please do NOT confuse it with a config file for your project - that one is described above in the first section of this document.\nServer-side configuration #  These values are used to configure packit service. No need to bother with them, they serve as a documentation for us, packit service developers.\n   Key name Type Description     keytab_path string path to a Kerberos keytab file (requires fas_user to be set)   github_app_id string github app ID used for authentication   github_app_cert_path string path to a certificate associated with a github app   webhook_secret string when specified in a Github App settings, GitHub uses it to create a hash signature with each payload    "});index.add({'id':25,'href':'/docs/cli/','title':"Packit CLI",'section':"User Documentation",'content':"Packit CLI #  To install packit CLI follow our guide.\nCommands #   build copr-build create-bodhi-update init local-build propose-downstream push-updates srpm status sync-from-downstream validate-config source-git init source-git update-dist-git  "});index.add({'id':26,'href':'/docs/cli/srpm/','title':"srpm",'section':"Packit CLI",'content':"srpm #  Create a SRPM of the present content in the upstream repository.\nBy default, packit uses git describe --tags --match '*.*' to create a unique version of the snapshot and git archive -o \u0026quot;{package_name}-{version}.tar.gz\u0026quot; --prefix \u0026quot;{package_name}-{version}/\u0026quot; HEAD to create a tarball with upstream sources.\nYou can override the archive and version commands in packit.yaml, e.g. this is what we use in ogr, a library which packit is using:\ncreate_tarball_command: [\u0026#34;python3\u0026#34;, \u0026#34;setup.py\u0026#34;, \u0026#34;sdist\u0026#34;, \u0026#34;--dist-dir\u0026#34;, \u0026#34;.\u0026#34;] current_version_command: [\u0026#34;python3\u0026#34;, \u0026#34;setup.py\u0026#34;, \u0026#34;--version\u0026#34;] Requirements #   Upstream project is using git. Packit config file placed in the upstream repository.  Tutorial #    Place a config file for packit in the root of your upstream repository..\n  Now we would generate a SRPM for ogr project:\n$ packit srpm Version in spec file is \u0026quot;0.0.3\u0026quot;. SRPM: /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm We can now build the package:\n$ rpmbuild --rebuild /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Installing /home/tt/g/user-cont/ogr/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.src.rpm Executing(%prep): /bin/sh -e /var/tmp/rpm-tmp.95VZ3c + umask 022 + cd /home/tt/rpmbuild/BUILD + cd /home/tt/rpmbuild/BUILD + rm -rf ogr-0.0.4.dev11+gc9956c9.d20190318 + /usr/bin/gzip -dc /home/tt/rpmbuild/SOURCES/ogr-0.0.4.dev11+gc9956c9.d20190318.tar.gz + /usr/bin/tar -xof - + STATUS=0 ... Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.aYyTMP ... Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.fotlPv ... + exit 0 Provides: python3-ogr = 0.0.4.dev11+gc9956c9.d20190318-1.fc29 python3.7dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 python3dist(ogr) = 0.0.4.dev11+gc9956c9.d20190318 Requires(rpmlib): rpmlib(CompressedFileNames) \u0026lt;= 3.0.4-1 rpmlib(FileDigests) \u0026lt;= 4.6.0-1 rpmlib(PartialHardlinkSets) \u0026lt;= 4.0.4-1 rpmlib(PayloadFilesHavePrefix) \u0026lt;= 4.0-1 Requires: python(abi) = 3.7 python3.7dist(gitpython) python3.7dist(libpagure) python3.7dist(pygithub) python3.7dist(python-gitlab) Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/tt/rpmbuild/BUILDROOT/python-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.x86_64 Wrote: /home/tt/rpmbuild/RPMS/noarch/python3-ogr-0.0.4.dev11+gc9956c9.d20190318-1.fc29.noarch.rpm + exit 0   Help #  Usage: packit srpm [OPTIONS] [PATH_OR_URL] Create new SRPM (.src.rpm file) using content of the upstream repository. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --output FILE Write the SRPM to FILE instead of current dir. --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). -h, --help Show this message and exit.  As you can see, it is possible to create SRPM for source-git repositories as well. Just add an --upstream-ref option to the packit command.\nIf you have a git tag 0.1.0 specifying the upstream code, just run packit srpm --upstream-ref 0.1.0 to create an SRPM file. It will create an archive from the given upstream reference (0.1.0) and following commits will be added as downstream patches.\nJust make sure, that you apply all the patches in the specfile. (Packit only adds the patches after the sources.) You can use a following setup:\n  Define the macro on top of the specfile:\n%global num_patches %{lua: c=0; for i,p in ipairs(patches) do c=c+1; end; print(c);}   Apply the patches in the %prep part:\n%if %{num_patches} git init git config user.email \u0026quot;noreply@example.com\u0026quot; git config user.name \u0026quot;John Foo\u0026quot; git add . git commit -a -q -m \u0026quot;%{version} baseline.\u0026quot; # Apply all the patches. git am %{patches} %endif   "});index.add({'id':27,'href':'/docs/actions/','title':"Actions",'section':"User Documentation",'content':"Actions #  You can probably find yourself in a situation where some part of the packit workflow needs to be tweaked for your package.\nPackit supports actions, a way to change the default implementation for a command of your choice. Packit is able to execute multiple commands. Each action accepts a list of commands. By default, the commands are executed directly and not in a shell - if you need a shell, just wrap your command like this: bash -c \u0026quot;my fancy $command | grep success\u0026quot;.\nAll actions are also executed inside Packit Service. The service creates a new sandbox environment where the command is run.\nActions have a default behaviour which you can override, hooks don\u0026rsquo;t have any - hooks are a way for you to perform operations following a certain packit event, e.g. cloning an upstream repo.\nCurrently, these are the actions you can use:\npropose-downstream command #      name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (main) and before other operations    [hook] pre-sync upstream git repo after cloning and checkout to the correct (release) branch     prepare-files upstream git repo after cloning, checking out of both upstream and dist-git repos replace patching and archive generation    create-patches upstream git repo after sync of upstream files to the downstream replace patching    get-current-version upstream git repo when the current version needs to be found expect version as a stdout parameter    Creating SRPM #  These apply to the srpm command and building in COPR.\n    name working directory when run description     [hook] post-upstream-clone upstream git repo after cloning of the upstream repo (main) and before other operations     get-current-version upstream git repo when the current version needs to be found expect version as a stdout    create-archive upstream git repo when the archive needs to be created replace the code for creating an archive    create-patches upstream git repo after sync of upstream files to the downstream replace patching    fix-spec-file upstream git repo after creation of a tarball and before running rpmbuild command this action changes spec file to use the new tarball    create-archive - is expected to return a relative path to the archive - relative within the repository. If there are more steps, then one of them has to return the archive name.\nfix-spec-file — this action updates the specfile so it\u0026rsquo;s possible to have the spec reference the tarball and unpack it. This method tries to perform 3 operations on a spec file:\n It replaces Source configured by spec_source_id (default Source0) with a local path to the generated tarball It changes the first %setup (or %autosetup) macro in %prep and adds -n so the generated tarball can be unpacked (it tries to extract the directory name directly from the archive or uses the configured archive_root_dir_template) It changes %version  For example a package may define multiple Sources. In such cases, the default implementation of fix-spec-file won\u0026rsquo;t be able to update %prep correctly. You can write a simple shell script which will be run with the cwd set to the root of the repository and use sed to set the new Sources correctly, e.g. sed -i my_specfile_path -e \u0026quot;s/https.*only-vendor.tar.xz/my_correct_tarball_path/\u0026quot;\nEnvironment variables set by packit #  Additionally, packit sets a few env vars for specific actions\nfix-spec-file\nPACKIT_PROJECT_VERSION — current version of the project (coming from git describe) PACKIT_PROJECT_COMMIT — commit hash of the top commit PACKIT_PROJECT_ARCHIVE — expected name of the archive\ncreate-archive\nPACKIT_PROJECT_VERSION — current version of the project (coming from git describe) PACKIT_PROJECT_NAME_VERSION — current name and version of the project (coming from git describe)\n In your package config they can be defined like this:\nspecfile_path: package.spec synced_files: - packit.yaml - package.spec upstream_package_name: package downstream_package_name: package dist_git_url: https://src.fedoraproject.org/rpms/package.git actions: prepare-files: \u0026#34;make prepare\u0026#34; create-archive: - \u0026#34;make archive\u0026#34; - \u0026#34;ls\u0026#34; "});index.add({'id':28,'href':'/docs/cli/sync-from-downstream/','title':"sync-from-downstream",'section':"Packit CLI",'content':"sync-from-downstream #  This is a detailed documentation for the downstream sync functionality of packit. The command creates a new pull request in upstream repository using a selected branch (main by default) from Fedora dist-git repository.\nRequirements #   Fedora dist-git repository. Packit config file placed in the upstream repository. Pagure API tokens for Fedora Dist-git. Github API token.  Tutorial #   Starting with packit 0.5.2 and later, you only need to set a single token to interact with dist-git. You needed two in the past. Please populate your local config at ~/.config/packit.yaml for packit so it can talk to the remote services:  # you can obtain the token over here: https://github.com/settings/tokens github_token: 123 # and this one right here: https://src.fedoraproject.org/settings#nav-api-tab pagure_user_token: 456   Files which are synced are mentioned in .packit.yaml as synced_files value.\n  Once you want to sync Fedora dist-git repo into the upstream repo, run packit sync-from-downstream in a working directory of your upstream repository:\n  $ git clone https://github.com/user-cont/colin.git $ cd colin $ packit sync-from-downstream upstream active branch master Cloning repo: https://src.fedoraproject.org/rpms/colin.git -\u0026gt; /tmp/tmph9npe78e using master dist-git branch syncing /tmp/tmph9npe78e/colin.spec PR created: https://api.github.com/repos/phracek/colin/pulls/3 packit sync-from-downstream \u0026ndash;help #  Usage: packit sync-from-downstream [OPTIONS] [PATH_OR_URL] Copy synced files from Fedora dist-git into upstream by opening a pull request. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --dist-git-branch TEXT Comma separated list of target branches in dist-git to sync from. (defaults to repo's default branch) --upstream-branch TEXT Target branch in upstream to sync to. (defaults to repo's default branch) --no-pr Do not create a pull request to upstream repository. --fork / --no-fork Push to a fork before creating a pull request. --remote-to-push TEXT Name of the remote where packit should push. If this is not specified, push to a fork if the repo can be forked. -f, --force Don't discard changes in the git repo by default, unless this is set. -x, --exclude TEXT File to exclude from sync -h, --help Show this message and exit.  "});index.add({'id':29,'href':'/docs/archive-not-matching-git/','title':"Generated code in upstream archives",'section':"User Documentation",'content':"When the release archive does not match the upstream git tag checkout #  This document covers a scenario when an upstream project has a script to create release archives and some of the code in the archive is generated. This means that when a downstream distribution has patches of the generated code those patches can\u0026rsquo;t be applied in the upstream repo.\nThe solution #  The provided solution will be performed in a source-git repository.\nWhen all your downstream patches apply cleanly on top of the upstream git repo for the particular git tag, then all is good and you don\u0026rsquo;t need anything special. You can follow the guide for the source-git init command to create such a source-git repo.\nThere is an issue when the patches require running tooling to regenerate code. Some upstream projects even use tooling which is not available downstream. Sadly, packit is unable to magically solve this scenario. If you cannot regenerate the code downstream, there is nothing that packit can offer. Alternatively you can fork the upstream project and start producing your own tarballs with patches of your choice - packit can help with setting this up, automate testing and the release process.\nAnother variant of this problem is when you need to patch code which is not present in the upstream repo and is present in the release tarball. It means your downstream patches (of the generated code) would not apply within the upstream repo.\nThere are two solutions to this:\n  Use upstream git history, patch regular sources instead and regenerate code in %prep.\n  Create additional commit with changes (run autogen.sh, generate documentation, etc.) so that you can apply the downstream patches.\n  Create the source-git repo from the tarball, not using the upstream git history.\n  Variant 1 #  This still follows the regular source-git repo. The problem may be when regenerating the does not fix the original problem or creates new problems - and you\u0026rsquo;ll really need to patch the generated sources.\nIn such a case, you should follow \u0026ldquo;Variant 3\u0026rdquo; since the code you need to patch is not present in the upstream repo.\nVariant 2 #  It\u0026rsquo;s a manual step to make which ensures that you still have upstream history and at the same time you can comfortably work with the package in the downstream.\nTo make packit ignore commits (so they are not generated as new downstream patches), just append a new line to the commit message:\nignore: true Variant 3 #  There is a tool to achieve this within the packit project: dist-git-to-source-git. Thought this tool was mainly used by the packit team and was not meant to be used outside of the team, please reach out and the team will be happy to assist you.\n"});index.add({'id':30,'href':'/docs/cli/status/','title':"status",'section':"Packit CLI",'content':"status #  This command displays latest information related to the project - downstream pull requests, upstream releases, builds in Koji and Copr and updates in Bodhi.\nHelp #  Usage: packit status [OPTIONS] [PATH_OR_URL] Display status. - latest downstream pull requests - versions from all downstream branches - latest upstream releases - latest builds in Koji - latest builds in Copr - latest updates in Bodhi Options: -h, --help Show this message and exit.  "});index.add({'id':31,'href':'/docs/cli/push-updates/','title':"push-updates",'section':"Packit CLI",'content':"push-updates #  Push the Bodhi updates that have been in testing for more than \u0026lsquo;Stable days\u0026rsquo; (7 by default) to the stable.\nHelp #  Usage: packit push-updates [OPTIONS] [PATH_OR_URL] Find all Bodhi updates that have been in testing for more than 'Stable days' (7 by default) and push them to stable. Options: --update-alias TEXT For example FEDORA-2019-ee5674e22c -h, --help Show this message and exit.  "});index.add({'id':32,'href':'/docs/cli/local-build/','title':"local-build",'section':"Packit CLI",'content':"local-build #  Create RPMs using content of the upstream repository.\nHelp #  Usage: packit local-build [OPTIONS] [PATH_OR_URL] Create RPMs using content of the upstream repository. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory Options: --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). -h, --help Show this message and exit.  "});index.add({'id':33,'href':'/docs/cli/validate-config/','title':"validate-config",'section':"Packit CLI",'content':"validate-config #  Validate the Packit configuration file.\nHelp #  Usage: packit validate-config [OPTIONS] [PATH_OR_URL] Validate PackageConfig validation. - checks missing values - checks incorrect types PATH_OR_URL argument is a local path or a URL to a git repository with packit configuration file Options: -h, --help Show this message and exit.  "});index.add({'id':34,'href':'/docs/cli/copr-build/','title':"copr-build",'section':"Packit CLI",'content':"copr-build #  Submit a Copr build of the present content in the upstream repository.\nRequirements #   Upstream git repository on Github. Packit config file placed in the upstream repository. ~/.config/copr  Tutorial #    Place a config file for packit in the root of your upstream repository.\n  The command below would create a SRPM from the present content of a repo and perform copr-cli build with it. If you need to specify a project name/owner or chroots, see the options in help.\n$ cd my/ustream/project/ $ packit copr-build   Help #  Usage: packit copr-build [OPTIONS] [PATH_OR_URL] Build selected upstream project in COPR. PATH_OR_URL argument is a local path or a URL to the upstream git repository, it defaults to the current working directory. Options: --nowait Don't wait for build --owner TEXT Copr user, owner of the project. (defaults to username from copr config) --project TEXT Project name to build in. Will be created if does not exist. (defaults to the first found project value in the config file or 'packit- cli-{repo_name}-{branch/commit}') --targets TEXT Comma separated list of chroots to build in. (defaults to 'fedora-rawhide-x86_64') --description TEXT Description of the project to build in. --instructions TEXT Installation instructions for the project to build in. --list-on-homepage Created copr project will be visible on copr's home-page. --preserve-project Created copr project will not be removed after 60 days. --additional-repos TEXT URLs to additional yum repos, which can be used during build. Comma separated. This should be baseurl from .repo file. E.g.: http://copr-be.clo ud.fedoraproject.org/results/rhughes/f20-gnome-3- 12/fedora-$releasever-$basearch/ --upstream-ref TEXT Git ref of the last upstream commit in the current branch from which packit should generate patches (this option implies the repository is source-git). --request-admin-if-needed Ask for admin permissions when we need to change settings of the copr project and are not allowed to do so. -h, --help Show this message and exit.  "});index.add({'id':35,'href':'/posts/july-2021/','title':"July 2021",'section':"Blog Posts",'content':"Week 26+27 (June 28th - July 9th) #  Summer is here and vacations with it. Most of the work done in this sprint is either internal (not user facing) or not finished yet.\n Thanks to MaťejM Packit Service now triggers a new Copr build if no suitable build has been found. That fixes an issue that the service sometimes did not react to /packit test. (packit-service#1132)  "});index.add({'id':36,'href':'/posts/june-2021/','title':"June 2021",'section':"Blog Posts",'content':"Week 22 (May 31st - June 4th) #   We have a new status page, kudos to Jirka! Franta fixed a bug that if some action during propose-downstream caused an upstream git repository to be dirty, the sync for other branches failed. (packit-service#1111) packit generate is not supported anymore. (packit#1269) Tomáš improved the patch ordering. (packit#1263)  Week 23 (June 7th - June 11th) #   Tomáš improved the way changelog is passed from source-git repo to dist-git. (packit#1265) Hunor created a new subcommand source-git to group source-git related commands init and update-dist-git. (packit#1273) František improved API by adding submitted_time to the test result. (packit-service#1113)  Week 24 (June 14th - June 19th) #   Franta started working on packit-service being able to submit test jobs to internal testing farm so teams can test upstream changes against RHEL. (packit-service#1124 packit#1280) Hunor continues working on packit source-git init: CLI is now more streamlined and simplified, and the command produces source-git repos matching our documentation. (packit#1277) Maťo Focko finished his refactoring of the Upstream class - should not have impact on our users, but make the code easier to work with. (packit#1157)  Week 25 (June 21st - June 26th) #   Hunor made several improvements to source-git init\u0026rsquo;s CLI. (packit#1284) Thanks to Frantisek there is now one COPR project/repo used for all releases. (packit-service#1128) Laura fixed a bug in syncing downstream to upstream. (packit#1285)  "});index.add({'id':37,'href':'/posts/may-2021/','title':"May 2021",'section':"Blog Posts",'content':"Week 18 (May 3rd - May 7th) #   Laura fixed the problem with fedora-latest alias (packit#1222). We now have separate workers for short and long running tasks. This should lead to better responsiveness (packit-service#1059, deployment#202).  Week 19 (May 10th - May 14th) #   Jirka added support for creating Bugzilla bugs for newly created MRs on GitLab (packit-service#1087). The installation instructions for failed or unfinished COPR builds are not displayed on the results page (dashboard#104).  Week 20 (May 17th - May 21st) #   Hunor created an update-dist-git command (packit#1228). Jan: use packit config as a place to create reference to tests (packit#1245).  Week 21 (May 24th - May 28th) #   Jirka added attribute for update-dist-git command to specify the packaging tool (e.g. centpkg). By default, fedpkg is used. (packit#1257, packit-service#1105). Tomáš added support for patch_id in the metadata of source-git commits. (packit#1252) Hunor improved the strategy of checking Copr results when we don\u0026rsquo;t receive that information over message-bus. (packit-service#1104)  "});index.add({'id':38,'href':'/posts/april-2021/','title':"April 2021",'section':"Blog Posts",'content':"Week 14 (April 4th - April 9th) #   Honza converted packit\u0026rsquo;s test suite from STI to FMF and configured packit to synchronize the suite to Fedora dist-git (packit#1192). Franta fixed a bug in packit which kept only appending targets to an existing COPR project which is no longer a case - dropped targets are now being removed (packit#1197).  Week 15 (April 12th - April 16th) #   Tomáš fixed an issue in chaining variable definitions in the RPM macros used to set up source-git repositories with packit init (packit#1206). Jirka improved the error message Packit Service emits when the request to start a test in Testing Farm fails (packit-service#1055). Laura made Packit Service to set a status for jobs as soon as the requests are received, and before starting any of the jobs (packit-service#1046). This way users will receive a more immediate feedback about the Service handling their requests.  Week 16 (April 19th - April 23th) #   The current_version_command and create_tarball_command config options are being deprecated in favour of actions. An issue will be created in the affected repositories if we find those options in use. (packit-service#1064) The result pages have been replaced by the views on our dashboard. Let us know what do you think about that and what information do you want to see there. You can expect more changes on this field.  The result views have been implemented by @IceWreck (dashboard#73). The integration on packit-service side has been done by Maťo (packit-service#1056, dashboard#95).    Week 17 (April 26th - April 30th) #   When initiating a new source-git repo, packit adds info about sources to packit.yaml. Also dist-git sources from the lookaside cache are not commited. (packit#1208, packit#1216). Franta added support for git repository cache into packit. The service part is yet to be done (packit#1214). Service reacts to /packit commands only when they appear alone on a line (packit-service#1065, packit-service#1083). Service doesn\u0026rsquo;t create duplicate issues when configuration is invalid (packit-service#1075). We deprecated current_version_command and create_tarball_command in packit config (packit#1212).  "});index.add({'id':39,'href':'/posts/march-2021/','title':"March 2021",'section':"Blog Posts",'content':"March 2021 #  Week 9 (March 1st - March 5th) #   Tomas improved the performance of sandcastle, all the user-defined actions now run in one sandbox. This should also speed up the SRPM builds. (packit#1129) You can view the results of jobs directly in our dashboard, kudos to Anchit. (dashboard#73) Jirka implemented setting of the environment context when running the Testing farm tests. (packit-service#1008) In Packit there is a new configuration option sources which overrides the URLs defined in specfiles. (packit#1131, packit#1143)  Week 10 (March 8th - March 12th) #   Jirka worked on setting up GitHub Workflows across all of the Packit repositories to build the container images for Packit Service and push them to Quay.io. Tomáš fixed a bug in the linearization mechanism used when generating patch files from a series of Git commits. (packit#1144) Hunor implemented a way for packit to detect if patch-files generated from Git are identical with the ones already in dist-git. This should help avoiding superfluous changes done by propose-downstream. (packit#1133) Jirka increased the delay (to 3 minutes in total) for Packit Service when retrying downloading the sources during a propose-downstream job. This should give more time for the sources to become available after a release is created. (packit-service#1019) Matěj fixed an ugly bug which caused Packit Service not to react to installation events. (packit-service#1018)  Week 11 (March 15th - March 19th) #   Laura fixed a bug in the processing of GitHub App installations. (packit-service#1020) Jirka fixed a bug that caused improper numbering of patches for source-git. (packit#1164)  Week 12 (March 22th - March 26th) #   Franta improved database schema. It will help us match builds and tests together more easily and solve some UX problems. (packit-service#954) packit init CLI command has been updated to  place downstream packaging files in a subdirectory .distro instead of fedora. (packit#1165) enable using Stream 9 dist-git as a source. (packit#1177)   Laura reworked how specfiles are being synced from downstream dist-git repositories and we are running a PoC for packit\u0026rsquo;s projects to test the new approach. (packit-service#1023) It\u0026rsquo;s possible to specify a distinct test repository for tests in a test job. (packit#1155) (packit-service#1021) centos-stream target is temporarily resolved to centos-stream-8 to reflect a change in Copr. (packit#1167)  Week 13 (March 29th - April 1st) #   Jirka fixed a bug in packit push-update (packit#1191). Matěj introduced the fedora-latest alias for build and test targets, which resolves to the latest branched Fedora Linux (packit#1187). A custom path for the package config (aka packit.yaml) can be specified using a new, top-level -c, --config option (packit#1184).  "});index.add({'id':40,'href':'/posts/february-2021/','title':"February 2021",'section':"Blog Posts",'content':"February 2021 #  Week 5 (February 1st - February 5th) #   The service uses new Testing Farm (API). We are still working on better user experience and fixing bugs. (packit-service#875) MatejF refactored permission system on pull requests and issues comments and renamed whitelist to allowlist. (packit-service#936) The service now retries failed tasks. (packit-service#931) --koji-target option of the CLI\u0026rsquo;s build command now accepts aliases. (packit#1052) The service runs on Fedora 33 now.  Week 6 (February 8th - February 12th) #   --dist-git-branches option in the CLI\u0026rsquo;s propose-downstream command was fixed, it now respects set branches. (packit#1094) The way Packit adds patches to spec-file in source-git repo was improved, now it shouldn\u0026rsquo;t fail if patches are sparsely numbered. (packit#1100)  Week 7 (February 15th - February 19th) #   The service now handles issue/MR comments on Gitlab. (packit-service#985) packit init command now works with CentOS packages. (packit#1106)  Week 8 (February 22th - February 25th) #   Sandcastle can run multiple commands in one sandbox, kudos to Tomas. (sandcastle#93) MatejF \u0026amp; MatejM improved CLI\u0026rsquo;s create-update to work with EPEL and add password prompt. (packit#1122, packit#1127) Service runs builds for targets from build + test jobs, kudos to Laura. (packit-service#996) MatejF did a lot of small fixes and improvements of packit-service. (packit-service#989, packit-service#993, packit-service#994)  "});index.add({'id':41,'href':'/posts/january-2021/','title':"January 2021",'section':"Blog Posts",'content':"January 2021 #  Week 1 (January 4th - January 8th) #   Name of the job/command/comment to propose update of downstream package has been synced between CLI and service to propose-downstream. propose-update is now deprecated. (packit#1065, packit-service#913)  Week 2 (January 11th - January 15th) #   Branch deletions are now correctly ignored. (packit-service#919) Multiple internal improvements have been done. (packit#1072, packit-service#922, packit-service#923)  Week 3 (January 18th - January 22th) #   We have temporarily disabled the testing-farm support because the cluster with old runner has died and the new runner is not ready. The tests are now skipped and you get Testing farm is temporarily disabled. status until we have the new runner available. (packit-service#929)  Week 4 (January 25th - January 29th) #   The CLI and the service now detect name of the default branch of a repository instead of assuming it to be called master. (packit#1074, packit-service#924) Build status page now points to the built SRPM uploaded to COPR. (packit-service#889) propose-downstream on source-git repositories now always uses --local-content. (packit#1093) Hunor fixed bug packit#1089 which caused a wrong revision to be used for certain jobs in Packit Service. Tomas improved the reliability of our sandboxing service. (sandcastle#95) Default branches in all our repositories have been renamed from master to main.  "});index.add({'id':42,'href':'/posts/december-2020/','title':"December 2020",'section':"Blog Posts",'content':"Week 49 (November 30th - December 4th) #   Jano fixed a bug in sync_release method of Packit API. (packit#1043) Jiri Konecny contributed a fix for how Packit creates COPR urls. (packit#1039) Laura updated instructions how to retrigger a job. (packit-service#892)  Week 50 (December 7th - December 11th) #   Tomas implemented the --upstream-url option of packit init command. When specified, init also sets up a source-git repository next to creating a configuration file.  Week 51 (December 14th - December 18th) #   Congratulations comments are now disabled by default, unless enabled in config. A bug, which prevented npm to be run during SRPM build, has been fixed. (sandcastle#86)  "});index.add({'id':43,'href':'/posts/november-2020/','title':"November 2020",'section':"Blog Posts",'content':"Week 45 (November 2nd - November 6th) #   Laura implemented an option for packit to copy description from a release into a changelog when running propose-update. Also the default message has been changed to the list of commit messages from last release. (packit#1004) Jano improved handling of build targets in packit. (packit#986) Tomas improved an experience of a contributor to source-git in case the contributor doesn\u0026rsquo;t follow git-am patches style that is used. (packit#1000)  Week 46 (November 9th - November 13th) #   Tomas improved the UX of logging in the CLI. (packit#1014) Jano improved logic of acquiring current version in the CLI. (packit#1013) We appreciate getting feedback from our users, if you could find some time to do so, there is an open issue for it.  Week 47 (November 16th - November 20th) #   Matej fixed an issue with Packit CLI, enabling recursive search for spec-files (packit#1005). It turned out, this change made it very easy to deplete GitHub API quota, so it was reverted. Laura made Copr builds to be part of the default jobs. This will cause build jobs to explicitly run, and display their own result flags in PRs, next to the test results. We hope this to be a more friendly behaviour for our new users (packit#1024).  Week 48 (November 23rd - November 27th) #   Laura fixed a bug, where Packit Service failed to trigger Copr builds before triggering the tests in case triggering Copr builds was configured for a different event. Thanks to Matej, Packit Service will now comment on commits in case Copr builds fail after a merge, in order to indicate the reason for the failure. Packit Service will soon stop commenting on PRs after the first successful build. The installation instructions from these comments were moved to the result page by Laura, while Matej added a warning to inform users about this upcoming change.  "});index.add({'id':44,'href':'/posts/october-2020/','title':"October 2020",'section':"Blog Posts",'content':"Week 41 (October 5th - October 9th) #   franta made triggering of jobs more reliable and in correct situations (packit-service#837)  Week 42 (October 12th - October 16th) #  Nothing significant happened during this week. The only change was that Hunor resolved a problem when sentry client library (the alert service we use) caused errors in stage environment and hence the problem didn\u0026rsquo;t make it to production.\nWe have also released a new version of packit: 0.18.\nWeek 43 (October 19th - October 24th) #  We finally had a week with plenty updates!\n We found out the hard way that one cannot build in Fedora koji directly from SRPM unless it\u0026rsquo;s a scratch build. The discussion with Fedora rel-eng is happening at pagure.io/releng/issue/9801 and in the meantime, all koji builds will be halted on our side since we know they cannot succeed. Do scratch: true for koji builds before this gets resolved. Packit creates a symlink for a generated archive at the root of the project. So far it only did it from a relative path and now absolute paths are supported as well. This is useful when your specfile is placed in a subdirectory and rpmbuild can\u0026rsquo;t find the archive. There is a new usability improvement to proposing a new downstream update. If the PR is already created, packit won\u0026rsquo;t create it again. You will no longer receive duplicate downstream PRs in dist-git. When doing a new downstream update, packit doesn\u0026rsquo;t sync %changelog since those are usually out of sync between upstream and downstream. Packit creates a new entry for the new release in the downstream. There is a new packit.yaml configuration option sync_changelog which bypasses this behaviour and copies the %changelog from upstream and overwrites the downstream changelog. Please use this option only when your changelogs are in sync. Documentation  Week 44 (October 26th - October 30th) #  No user-facing changes in packit(-service) this week.\n"});index.add({'id':45,'href':'/posts/fedora-eln/','title':"Working on the next major RHEL release, in your upstream repo",'section':"Blog Posts",'content':"Fedora EL Niño (ELN) is such an awesome idea. It enables building rawhide packages in two distinct buildroots:\n the standard Fedora Rawhide buildroot and a second one, which mimics Red Hat Enterprise Linux  This way you can make sure that your new upstream release builds fine in the next RHEL.\nBut this feedback might be a little bit too late: the upstream release already happened and the code was imported in Fedora dist-git, so fixing an issue will require repeating the whole process. Wouldn\u0026rsquo;t it be better to know if the upstream change builds fine in ELN while working on the code?\nOh, wait!\nYou can do this easily with Packit #  If your GitHub project is not using Packit yet, here\u0026rsquo;s a guide how to start.\nOnce it\u0026rsquo;s set up, you need to make sure that your pull requests are also being built in the fedora-eln target:\njobs: - job: copr_build trigger: pull_request metadata: targets: - fedora-development - fedora-eln With this config, changes from every pull request will be built in all development versions of Fedora (at the time of writing this, it\u0026rsquo;s Rawhide and Fedora 33) and in Fedora ELN.\nEasy, right?\nPackit can also trigger builds when you push to a branch. If you want to have up to date builds of your main branch for ELN and development versions of Fedora, here\u0026rsquo;s how to set it up:\njobs: - job: copr_build trigger: commit metadata: targets: - fedora-development - fedora-eln branch: main A real-life example #  If you got here and you\u0026rsquo;re still not sure why you\u0026rsquo;d need this, I can give you a real-life example.\nRecently, Jirka Konecny from the RHEL Installer team reached out to us that they would love to use Packit as a CI system. He set it up and now all the anaconda PRs are being built and tested on Fedora Rawhide x86_64.\nJirka continued and added Fedora ELN as an additional target. The build failed because one of build requirements was not available in ELN:\nFedora ELN - Developmental modular packages for the next Enterprise Linux release 2.7 kB/s | 2.3 kB 00:0 No matching package to install: 'metacity' Not all dependencies satisfied Error: Some packages could not be found. Since the team discovered this during their upstream development process, they can react to the issue right away. It would have been pretty late if they found this while the next major RHEL is reaching alpha - at this moment they should have enough time to fix the problem and make sure anaconda builds fine in ELN.\nSo, are you convinced? Let us know if you need help setting up Packit in your upstream repositories :)\n"});index.add({'id':46,'href':'/posts/september-2020/','title':"September 2020",'section':"Blog Posts",'content':"Week 36 (August 31th - September 4th) #   We store the submission time of SRPM builds now (packit-service#795 by Anchit). Shreyas improved implementation of the build status reporting (packit-service#740). Anchit enhanced the /koji-builds endpoint to be more consistent with /copr-builds endpoint (packit-service#791).  Week 37 (September 7th - September 11th) #   Stage now uses Tokman to get access tokens for GitHub, which should resolve race condition when running parallel jobs (Tokman by Hunor, ogr integration by Matej). Franta has addressed problems with Testing-Farm cluster with custom response on PRs that links to more information (pinned info, packit-service#798).  Week 38 (September 14th - September 18th) #   The combination of the source-git patches with existing patches now works well (packit#963). Service now mostly supports also GitLab as you can see here or here. A lot of small issues were fixed in the last week (packit-service#806, packit-service#812, packit-service#814, packit-service#815, packit-service#816 ). Created Copr projects are now prefixed with the hostname for non-GitHub services and also support multipart namespaces (packit-service#819). Laura fixed two testing-farm related issues (packit-service#808, packit-service#809). You can now use test job also on Pagure and GitLab thanks to that.  Week 39 (September 21st - September 25th) #   Packit-service can be configured to work with private namespaces. This is plumbing work which we need right now for CentOS Stream. We are not planning to enable this for GitHub - packit-service will still work only for public repositories, private ones are ignored. packit-service#831 If git tag contains more information than just version (e.g. pkg_name-v1.2.3), it is possible to use upstream_tag_template to extract version from the tag, which will be used in a subsequent task. doc packit#959 Added support for globbing pattern in upstream_ref. doc packit#960 Packit --remote is global option now and available for all commands. Because of this sync-from-downstream --remote was renamed to --remote-to-push. Remote can now be specified in the user\u0026rsquo;s config (via upstream_git_remote parameter). packit#977  Following bugs were fixed:\n Packit dropping leading zeros in version. packit#814 Packit CLI issue caused by picking incorrect copr project name. packit#971  Week 40 (September 28th - October 2nd) #   Packit-service is now explicitly checking if requested copr-build targets exist and if not, the user is informed about it. packit-service#835 We have improved the way how packit updates %setup line in a spec file - you are now able to set content of -n option via archive_root_dir_template config option, it defaults to {upstream-pkg-name}. doc packit#834 Packit is able to generate a patch file with format-patch without leading a/ and b/ in the patch diff. Required for patches in dist-git which are applied with -p0. Contribution guidelines were updated, now we have one shared link.  "});index.add({'id':47,'href':'/posts/august-2020/','title':"August 2020",'section':"Blog Posts",'content':"Week 32 (August 3rd - August 7th) and 33 (August 10th - August 13th) #   We renamed our GitHub organisation to packit. That user had been inactive for a long time and Hunor\u0026rsquo;s request was successful. The Copr project settings are now changed only if needed. If we can\u0026rsquo;t edit the settings, we ask for the admin access to the Copr project and the service shows you a table with the changes if you want to do the edit manually. (packit#921, packit-service#764) Matej fixed an old bug with the custom command for creating archives. The archive was not found when building SRPM because of the incorrect processing of the paths from the command output. (packit#923)  Week 34 (August 17th - August 20th) #   Tomas tought packit how to merge related commits, which were previously created by git-am applying of a multiple commit patch. (packit#933) Anchit added new /api/srpm-builds/ endpoint. Service now requests \u0026lsquo;builder\u0026rsquo; permission for custom projects if needed. Franta fixed a problem with only one job executed executed for 2 build definitions for the same trigger.  Week 35 (August 24th - August 28th) #   Tomas improved logging of the Packit actions' output. (packit#950) Anchit fixed and enhanced the /api/srpm-builds endpoint. (packit-service#788)  "});index.add({'id':48,'href':'/posts/july-2020/','title':"July 2020",'section':"Blog Posts",'content':"Week 27 (June 29th - July 3rd) #  packit #   We introduced a new command packit validate-config which validates the contect of a package configuration file in your project (contributed by @TomasJani, #826).  packit-as-a-service #   You are now able to override configuration for builds, releases and other jobs (by @TomasTomecek, #676). Read more about this feature here.  Week 28 (July 6th - July 10th) #  packit #   Command validate-config works properly now and does not produce odd error messages, by @TomasTomecek and @csomh, #894 and #895 You will now properly see git-describe metadata in the %release field in spec file when using srpm command, by @TomasTomecek, #894 git-log is being used to get a list of commits between HEAD and latest tag to pick up commit messages and add those to %changelog, by @TomasTomecek, #889 packit is now able to load metadata from commits of a source-git repo and utilize them when creating patch files, by @lachmanfrantisek, #875  packit-as-a-service #   We now have a new API endpoint: /api/projects/, by @IceWreck, #716 Over the last few weeks, @lbarcziova was very busy with refactoring how jobs and tasks are being executed in packit-service. This work is now complete which allows us to scale the deployment up while giving us better introspection in what\u0026rsquo;s happening inside, by @lbarcziova, #704  Week 29 (July 13th - July 17th) #  Copyright (c) Dominika Hodovska. This work is licensed under a Creative Commons Attribution 4.0 International License.\nWeek 30 (July 20th - July 24th) #   Anchit added a few new API endpoints to Packit-as-a-Service to retrieve project information. This is used in the Dashboard, to provide an overview of the projects served by Packit.  Week 31 (July 27th - July 31st) #   Jano did a lot of work on our deployment. The installation of all our dependencies is much simpler now. (packit-service#747, packit-service#753, packit-service#756, packit-service#757, packit#919), Packit now puts a link to our documentation in a pull request status when a contributor is not allowed to build the PR, thanks to Tomáš. (packit-service#758)  "});index.add({'id':49,'href':'/posts/june-2020/','title':"June 2020",'section':"Blog Posts",'content':"Week 23 (June 1st - June 5th) #  Hello everyone, during this week we didn\u0026rsquo;t manage to implement any significant new features - most of the work happened under the hood.\npackit #   We have fixed a formatting issue when packit prints installation instructions for using builds from a copr repo (by @lachmanfrantisek, #852). You are able to set up builds when you push to a branch, we have set this up for master branch of packit, feel free to get inspired (by @lachmanfrantisek, #851).  packit-as-a-service #   We have run into multiple problems when you set up jobs for PRs and branch pushes - there were multiple fixes for this, packit-service wasn\u0026rsquo;t able to work well with the fact that there are multiple jobs defined for the same job type - e.g. build.  Week 24 (June 8th - June 11th) #  packit #   Tomas re-implemented overriding of package config per job. This will enable overriding configuration for builds and releases once the corresponding changes are merged in Packit-as-a-Service. (#858, #859).  packit-as-a-service #   We are now parsing events from Koji about the progress of the builds and report them (by Franta, #657). We are now able to listen to Gitlab hooks and parse the (comment \u0026amp; push) events (by Shreyas, #629, #671). Log pages have been restructured by linking SRPM build logs instead of including them (by Hunor, #641).  Week 25 (June 15th - June 19th) #  packit #   Packit logs more information for RebaseHelper errors (by @csomh, #865).  packit-as-a-service #   Obtaining builds via packit API endpoint is now significantly quicker (by @IceWreck, #674). We now have an API endpoint for obtaining results from testing farm (by @IceWreck, #678). We finished the implementation of the trigger to create bugs in Bugzilla. Therefore packit is now able to create bugzilla for accepted PR\u0026rsquo;s in CentOS (by @jpopelka, #662).  Week 26 (June 22th - June 26th) #  packit #   packit now supports using custom repositories and packages when building in Copr and has options to preserve the project and to list it in on the Copr home page @lachmanfrantisek, #872. Custom commands defined by user in packit config now are run in the shell, no more bash -c required (by @TomasTomecek, #871). packit now includes pull request ID in version of rpm. (by @sturivny and @TomasTomecek, #870).  packit-as-a-service #   We added support for copr builds in gitlab (by @shreyaspapi, #683). packit-service utilizes the new options introduced in packit (by @lachmanfrantisek, #694).  "});index.add({'id':50,'href':'/posts/may-2020/','title':"May 2020",'section':"Blog Posts",'content':"Week 19 (May 4th - May 6th) #  packit #   The image now uses ogr from git master instead of from Fedora stable RPM.  packit-service #   Franta Fixed a previous week introduced bug, which prevented users from being whitelisted. (#599) Hunor Made improvements to avoid a race condition in getting app access token. (#601)  Week 20+21 (May 11th - May 22th) #  packit #   The debug logs in the CLI are now much more consistent. (#824) A bug in the propose-update causing problems with the synchronization of the spec-file content was fixed. (#830) You can now use epel-all alias in the arguments and also in the configuration. (#835)  packit-service #   In job definition for packit-service you can use epel-all alias as well. (#835)  Week 22 (May 25th - May 29th) #  packit #   The problem with kerberos initialization was fixed. (#838) We released a new version of the packit package. (release 0.11.0) We have been also working on some smaller issues and preparation steps for our future work. (#841, #843, #846, #847)  packit-service #   Jirka implemented creating a new bug in Bugzilla for CentOS Stream pull-requests (#627). This will be triggered when the label \u0026ldquo;accepted\u0026rdquo; is added to a PR in the (near) future. You will be able to use aliases also for koji builds. (packit:#839, #632) Laura fixed a problem with missing builds when triggering Packit Service with /packit test. Now, we trigger the build first if there are no builds for the pull-request yet. (#631)  "});index.add({'id':51,'href':'/posts/april-2020/','title':"April 2020",'section':"Blog Posts",'content':"Week 14 (March 30th - April 3rd) #  packit #   Fix web URLs for Copr builds owned by groups (#778). Create downstream spec if it\u0026rsquo;s not there (propose-update) - this used to happen when using packit on a newly created package in Fedora which did not have spec fille added yet. (#779) Packit no longer inspects archive extension set in Source and creates .tar.gz by default - this should be more flexible and prevent issues for \u0026ldquo;non-standard\u0026rdquo; archive names. (#781)  packit-service #   Several fixes and improvements after switching data store from Redis to PostgreSQL. Use the configured COPR project when triggering Testing Farm (tests no longer fail for projects which are built in their own COPR namespace) (#524).  Week 15 (March 6th - April 9th) #  packit #   Tomáš finished teaching packit srpm to linearise extremely complex Git histories, in order to get patches that can be applied when building the SRPM. Jirka made the schema validation code Marshmallow3 compatible. This enables building packit in Fedora 32 and Rawhide.  packit-service #   Franta fixed an issue with parsing release events. Jirka made code Marshmallow3 compatible in this project, too.  Week 16 (April 14th - April 17th) #  packit \u0026amp; packit-service #   Job metadata field dist-git-branch is now marked as deprecated, to be replaced by dist_git_branches to match the naming of other metadata fields and to accept multiple branch names where Packit should work. (#797, #788 and #564). A great deal of refactoring, CI work and general code improvements which will make Packit and Packit Service run smoother and development easier.  Week 17 (April 20th - April 24th) #  packit-service #  In this week we mostly focused on CentOS Stream and some under the hood improvements, none of which are available for Github projects.\n Jano did a lot of work on initial CentOS Stream integration. Hunor added a Pagure build status reporting. Anchit added first API tests and improved build statuses given by the API. Laura and Rishav improved how data about Copr builds are stored in our db.  Week 18 (April 27th - April 30th) #  packit-service #   Franta did a great deal of service \u0026amp; worker refactoring related to CentOS (#586) and to forks usage in Github. (#589) Hunor fixed confusing Github status messages while building in Copr. (#588)  "});index.add({'id':52,'href':'/posts/march-2020/','title':"March 2020",'section':"Blog Posts",'content':"Week 10 (March 2nd - March 6th) #  packit #   The generate command is now deprecated in favour of the init command (#728), contributed by @shreyaspapi.  packit-service #   When a non-collaborator creates a PR, packit says that only \u0026ldquo;Collaborators can trigger packit-service\u0026rdquo; - this message has been improved to better match the reality (#445). Packit service no longer posts comments on pull requests when a SRPM can\u0026rsquo;t be created - the logs should be now aviable in the service\u0026rsquo;s logs view available when clocking on the commit status check URL (#447). Commands to control packit service can now be embedded in a comment (previously, the whole comment was treated as a command) - hence you can now create a comment to give an update and also trigger packit (#433), contributed by @IceWreck. We have improved monitoring of packit-service by using more sentry.io\u0026rsquo;s features (#458). You can now disable the functionality when packit service comments on a PR when it gets built for the first time (notifications: {pull_request: {successful_build:: false}} in your packit.yaml), hi Lars! (#455).  Week 11 (March 9th - March 13th) #  packit #   We have changed how packit treats version and release in the spec file (#748).  We handle the git-describe output better which should help when tags contain dashes (#759).   When packit adds source-git patches into a spec file it adds them outside of rpm macros now (#760). In pull request pipelines we run the packit-service tests so that we are sure we do not break the service (#752).  packit-service #   Comments from packit-service about successful propose-update in the issue which triggered the update now include the URL of the new pull-request in Fedora (#472). We have done some major refactoring how jobs are processed (#476), (#746), (#453). Development and debugging of the packit-service should be easier now, we documented how to run packit-service locally (#473).  Week 12 (March 16th - March 20th) #  packit #   When you are executing copr-build command, you do not need to set the project name if this value is defined in the copr_build job in the configuration file (#763). All patches generated from a source-git repo are now prefixed with a number so they are easy to sort (#765). We improved the behaviour when loading the authentication in the config file - users are warned only if deprecated keys are used, no more confusing messages when you do not have authentication key in the configuration (#754).  packit-service #   We periodically check the status of the copr-build so that we do not need to rely on the Fedora message bus. This should avoid failures in build status reporting (#490). Propose-update triggered by comment in Github now recognizes also pre-releases (#498). Several bugs in how we report results from Testing farm have been fixed and Testing farm results should now appear correctly in commit status checks (#496), (#505), (#510), (#513).  Week 13 (March 23th - March 27th) #   New Packit version 0.9.0 was released. Packit Service now mostly uses PostgreSQL instead of Redis as a backend, which will result in more responsive API and Dashboard.  "});index.add({'id':53,'href':'/posts/february-2020/','title':"February 2020",'section':"Blog Posts",'content':"Week 6 #  Both Packit and Packit Service pre-commit hooks were updated to include prettier and setup-cfg-fmt, in order to have a more consistent formatting of markup, YAML, JSON and setup.cfg files.\nIt became easier for developers to build the Packit base image locally, and tests in Zuul were configured to run on Fedora 31.\nPackit learned how to look for RPM spec files on its own, so specifying specfile_path in the configuration is not mandatory anymore. Packit will recursively search the tree and use the first spec file found.\nThe Redis pod in Packit Service uses an up to date image now, based on Fedora 31. Kudos to hhorak for the help!\nWeek 7 #  The default configuration generated by Packit has test jobs enabled from now on. This should simplify configuring Packit in new repositories.\nFixed a bug which was causing SRPM-build failures in Packit Service for projects which had their spec files stored in a subdirectory.\nAs a result of keys.fedoraproject.org being turned off, Packit now tries a list of GPG keyservers when downloading keys to check commit signatures.\nWhen enabling Packit Service for new GitHub repositories, instead of checking if the requester is a Fedora packager, we\u0026rsquo;ll check if they signed the Fedora Project Contributor Agreement.\nWhile proposing an update to Fedora, Packit Service will report a failure now when there are no releases found in the upstream GitHub repository.\nTest results became serializable, we will not block when no test results are received, and Packit Service received some initial code to enable using PostgreSQL as a data backend.\nWeek 8 #  Postgresql database was introduced in production environment to improve performance and enable implementation of new features, e.g. storing logs to reduce amount of messages sent directly to pull request (#406), (#420).\nCleanup in configuration files was performed, so no longer needed values were removed from .packit.yaml (#709). User experience was improved by adding new --upstrem-ref option to copr-build command in command-line interface (#718) and making error reporting more robust by adding new fedpkg clones related error message (#714).\nFollowing bugs were fixed:\n bug in copr-build command fixed (#713) get_local_package_config() duplicate entries in \u0026lsquo;directories\u0026rsquo; bug fixed (#715)  Week 9 #  packit #   Dist-git patches are now applied in source-git repos with -p1 to resolve an issue when they are generated with git and patch program fails to apply them (#730). Fedora 32 was added to \u0026lsquo;fedora-all\u0026rsquo; and \u0026lsquo;fedora-development\u0026rsquo; aliases (#731). We have put more links to our documentation (README, deprecation warning in packit) so that people can easily correct their configuration files (#726).  packit-service #   targets key in copr job definition in the packit.yaml is no longer a required field (it defaults to fedora-stable) (#431). Builds are now correctly linked to their actual GitHub projects (this can be seen in the logs view) (#441).  "});index.add({'id':54,'href':'/posts/january-20/','title':"January 2020",'section':"Blog Posts",'content':"Week 1 #  packit #   Correctly updates version on srpm build. (#642) Downloads all URL sources before srpm build. (#643)  packit service #   Runs on Fedora 31. (#303, #304) Correctly checks list of whitelisted repositories when issue comment is added. (#309)  Week 2 #  packit #   Incorporates lots of SRPM related improvements. (#646, #650, #651, #652, #653) Better handles when Copr owner is not set. (#648)  packit service #   Fixes SRPM exceptions/errors handling. (#311, #317) Has loading of config fixed. (#318)  Week 3 #  packit #   Uses Marshmallow for configuration schema. (#657) Is able to build in Koji from upstream/source-git. (#658) Doesn\u0026rsquo;t download remote sources when \u0026ldquo;sources\u0026rdquo; path exists in upstream. (#659) Configuration file allows list syntax in action commands. (#663) Configuration can use a new option to exclude paths from patching. (#666) Has few less bugs. (#660, #661, #664, #667)  packit service #   Uses Marshmallow for configuration schema. (#320) Runs build for test job even when it\u0026rsquo;s not explicitly configured. (#324) Reports invalid or missing packit config. (#328) Status workflow has been changed and simplified. (#338) Minor fixes. (#323, #326, #329, #331, #335, #336)  Week 4 #  packit #   0.8.1 has been released. CLI has bash auto completion. (#654) Few bugs have been squashed. (#668, #670, #676, #677, #678, #680, #682)  packit service #   More checks messages have been unified. (#355) One more testing-farm status is now shown before the tests are submitted. (#343) No-fmf scenario has better messages. (#362) Minor fixes and improvements. (#339, #340, #342, #345, #346, #347, #348, #352, #353, #350, #357, #358, #361, #364)  Week 5 #  packit #   CLI has a new command for local build. (#687) Logs less. (#685)  packit service #   Minor fixes and improvements. (#365, #371, #373, #376)  "});index.add({'id':55,'href':'/posts/2019/','title':"2019",'section':"Blog Posts",'content':"Initial version 0.1.0 of packit is out! (2019-03-08) #  We would like to announce general availability of the initial version of packit, titled \u0026lsquo;0.1.0\u0026rsquo;.\nSince this is our first release, we would like to ask you to be patient if you encounter any issues. We work hard on packit\u0026rsquo;s usability. If you feel like that packit is doing something weird or if anything is unclear, don\u0026rsquo;t hesitate and reach out to us by creating a new Github issue.\nThe initial release contains two commands:\n packit propose-update — Opens a pull request in dist-git for the latest upstream release of a selected repository. packit watch-releases — Watches events for all the upstream releases and performs propose-update for those who use packit.  Installation #  $ dnf install --enablerepo=updates-testing packit Or\n$ pip3 install --user packitos Or (if you\u0026rsquo;re brave)\n$ pip3 install --user git+https://github.com/packit-service/packit Requirements #  Present features have strict requirements on the upstream projects:\n  You need to have a packit config file present in the upstream repo.\n  You need to have spec file present in the upstream repo.\n  This workflow is suitable for people who are both upstream and downstream maintainers of the particular project. If you don\u0026rsquo;t fit into that bucket, then packit might not be ready for you, yet. Please wait till we land more source-git related functionality into packit.\npropose-update #  I\u0026rsquo;m going to demonstrate this functionality on ogr, our library for git forges, which powers packit.\nIt was recently approved for Fedora, so we can use packit to bring the initial version of ogr into Fedora Rawhide, 30 and 29.\nDo we have everything? #  Let\u0026rsquo;s see guide for the propose-update command on what we need:\n0. The upstream repository with a valid upstream release. #  $ git remote -v origin git@github.com:TomasTomecek/ogr.git (fetch) origin git@github.com:TomasTomecek/ogr.git (push) upstream https://github.com/packit-service/ogr.git (fetch) upstream https://github.com/packit-service/ogr.git (push) Yup.\n$ git tag --list 0.0.1 0.0.2 0.0.3 $ git checkout 0.0.3 Note: checking out '0.0.3'. And the tag name is matching the version in a spec file:\n$ grep Version python-ogr.spec Version: 0.0.3 1. Packit config file placed in the upstream repository. #  $ ll .packit.yaml -rw-rw-r--. 1 tt tt 177 Mar 1 17:44 .packit.yaml Check.\n2. Spec file present in the upstream repository. #  $ ll python-ogr.spec -rw-rw-r--. 1 tt tt 1.3K Mar 1 17:43 python-ogr.spec :+1:\n3. Pagure API tokens for Fedora Dist-git. #  $ env | grep TOKEN PAGURE_USER_TOKEN=will PAGURE_FORK_TOKEN=not GITHUB_TOKEN=share, sorry 4. Valid Fedora Kerberos ticket. #  $ kinit ttomecek@FEDORAPROJECT.ORG Password for ttomecek@FEDORAPROJECT.ORG: $ klist Ticket cache: KEYRING:persistent:1024:krb_ccache_g0t1Ty3Ah Default principal: ttomecek@FEDORAPROJECT.ORG Valid starting Expires Service principal 03/01/2019 18:12:25 03/02/2019 18:12:19 krbtgt/FEDORAPROJECT.ORG@FEDORAPROJECT.ORG renew until 03/08/2019 18:12:19 We\u0026rsquo;re all set!\nTime to shine #  We are still in the \u0026ldquo;ogr\u0026rdquo; upstream git repository.\n$ packit propose-update INFO: Running 'anitya' versioneer ERROR: Failed to determine latest upstream version! Check that the package exists on https://release-monitoring.org. using \u0026quot;master\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmp2e65b0xt/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/1 Mind-blowing, isn\u0026rsquo;t it? Now we have latest python-ogr in Fedora Rawhide by running only a single command.\nI have also added ogr into release-monitoring as packit suggests.\nOnce we are okay with the changes, we have to merge the pull request. That\u0026rsquo;s our responsibility, as maintainers.\nBuilding in koji #  Time to build the package (packit doesn\u0026rsquo;t support building in koji, yet)\n$ fedpkg clone python-ogr Cloning into 'python-ogr'... remote: Counting objects: 8, done. remote: Compressing objects: 100% (5/5), done. remote: Total 8 (delta 0), reused 5 (delta 0) Receiving objects: 100% (8/8), done. $ cd python-ogr $ git log commit c298df5e540ba1d010366e102c1c75d4f5b0b0cc (HEAD -\u0026gt; master, origin/master, origin/HEAD) Author: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; Date: Fri Mar 1 18:15:00 2019 +0100 [packit] 0.0.3 upstream release more info Signed-off-by: Tomas Tomecek \u0026lt;ttomecek@redhat.com\u0026gt; commit 7d5ab1471ca0ee2a6c0254410b83beaa83b80f0b Author: Gwyn Ciesla \u0026lt;limb@fedoraproject.org\u0026gt; Date: Fri Mar 1 15:18:34 2019 +0000 Added the README Yup, that\u0026rsquo;s our commit. more info was added there by accident, this is already fixed in packit.\n$ fedpkg build Building python-ogr-0.0.3-1.fc31 for rawhide Created task: 33125435 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33125435 Watching tasks (this may be safely interrupted)... 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): free -\u0026gt; open (buildvm-14.phx2.fedoraproject.org) 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) 33125436 buildSRPMFromSCM (/rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): closed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 1 open 2 done 0 failed 33125464 tagBuild (noarch): closed 33125451 buildArch (python-ogr-0.0.3-1.fc31.src.rpm, noarch): open (buildvm-14.phx2.fedoraproject.org) -\u0026gt; closed 0 free 0 open 4 done 0 failed 33125435 build (rawhide, /rpms/python-ogr.git:c298df5e540ba1d010366e102c1c75d4f5b0b0cc) completed successfully That was rough, can\u0026rsquo;t wait to do this with packit.\nLet\u0026rsquo;s do Fedora 30 now:\n$ packit propose-update --dist-git-branch f30 INFO: Running 'anitya' versioneer using \u0026quot;f30\u0026quot; dist-git branch syncing ./python-ogr.spec INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.0.3.tar.gz 100%[=============================\u0026gt;] 17.95K eta 00:00:00 downloaded archive: /tmp/tmpl5xxq22x/ogr-0.0.3.tar.gz uploading to the lookaside cache PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/3 And so on\u0026hellip;\nConclusion #  As you can see, packit is useful for us right away.\nWe\u0026rsquo;ll be delighted if you try it out and let us know what you think.\nPackit 0.2.0 is here! (2019-03-19) #  Our sprint nears an end which means we have released a new version of packit - 0.2.0! You can expect a new release after every sprint (i.e. every 2 weeks).\nThe 0.2.0 version has a bunch of new features and improvements: you can find a complete list in the changelog. We also have a detailed documentation for all the workflows packit covers.\nLet\u0026rsquo;s get through what\u0026rsquo;s new:\n We have decided to rename two keys in our config file so they are more descriptive. Old names still work but they are deprecated:  package_name → downstream_package_name upstream_name → upstream_project_name   You don\u0026rsquo;t need to touch dist-git at all when getting your new upstream release into Fedora, you can stay in your upstream repository and just fire off a bunch of packit calls:  packit propose-update to create a pull request in Fedora dist-git with the selected upstream release packit build to build the new upstream release once the pull request is merged and finally, packit create-update creates a new bodhi update (if you chose a stable Fedora release)   Packit now has a srpm command which creates an SRPM out of the local content of your upstream repository. You can now use packit to sync files from your dist-git repo back into upstream (mainly to keep spec files in sync). sync-from-downstream is the command. Command propose-update received numerous improvements:  You can pick upstream version to use. Packit will NOT check out the git ref with the upstream release if you specify --local-content It\u0026rsquo;s possible to force packit to execute fedpkg new-sources using --force-new-sources and bypass the caching mechanism.    Installation #  Please make sure you are installing 0.2.0:\n$ dnf install --enablerepo=updates-testing packit Or\n$ pip3 install --user packitos You can also install packit from master branch, if you are brave enough:\n$ pip3 install --user git+https://github.com/packit-service/packit How are we using packit? #  I\u0026rsquo;d like to show you how we used packit to bring a new upstream release of ogr into Fedora, a library which packit is using.\nOnce we have performed an upstream release of ogr, we can propose an update in dist-git:\n$ git clone https://github.com/packit-service/ogr \u0026amp;\u0026amp; cd ogr/ $ packit propose-update INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.0.3'. Picking version of the latest release from the upstream registry over spec file. Checking out upstream version 0.0.3 Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpb9xlvdhj Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.0.3.tar.gz found in lookaside cache (skipping upload). ERROR Cmd('git') failed due to: exit code(1) cmdline: git commit -s -m [packit] 0.0.3 upstream release -m Upstream tag: 0.0.3 Upstream commit: 059d21080a7849acff4626b6e0ec61830d537ac4 stdout: 'On branch 0.0.3-master-update nothing to commit, working tree clean' Whoops, it seems that I have messed up, I forgot to bump the spec file in the upstream repo when doing the release. I will bump it locally and utilize --local-content argument:\n$ rpmdev-bumpspec -n 0.1.0 -c 'New upstream release: 0.1.0' *.spec $ packit propose-update --local-content INFO: Running 'anitya' versioneer Version in upstream registries is '0.0.3'. Version in spec file is '0.1.0'. Picking version of the latest release from the upstream registry over spec file. Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpd9j4se27 Syncing /home/tt/g/user-cont/ogr/python-ogr.spec Archive ogr-0.1.0.tar.gz found in lookaside cache (skipping upload). INFO: Downloading file from URL https://files.pythonhosted.org/packages/source/o/ogr/ogr-0.1.0.tar.gz 100%[=============================\u0026gt;] 20.25K eta 00:00:00 Downloaded archive: '/tmp/tmpd9j4se27/ogr-0.1.0.tar.gz' About to upload to lookaside cache won't be doing kinit, no credentials provided PR created: https://src.fedoraproject.org/rpms/python-ogr/pull-request/6 Once the scratch build is done and tests passed we merged and built it:\n$ packit build Using 'master' dist-git branch Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmprp3cmdjy Building python-ogr-0.1.0-1.fc31 for rawhide Created task: 33616980 Task info: https://koji.fedoraproject.org/koji/taskinfo?taskID=33616980 We have done the same for F30 and F29.\nThe previous commands were run in the directory of the upstream repository. Packit also accepts path to your upstream clone, or even URL. So let\u0026rsquo;s create a bodhi update for python-ogr by specifying the upstream repo URL:\n$ cd $HOME $ packit create-update --dist-git-branch f29 https://github.com/packit-service/ogr Cloning repo: https://github.com/packit-service/ogr -\u0026gt; /tmp/tmpdkdadmn_ Koji builds for package python-ogr and koji tag f29-updates-candidate: - python-ogr-0.1.0-1.fc29 Cloning repo: https://src.fedoraproject.org/rpms/python-ogr.git -\u0026gt; /tmp/tmpn1809ec9 Bodhi update FEDORA-2019-78948e62d2: - https://bodhi.fedoraproject.org/updates/FEDORA-2019-78948e62d2 - stable_karma: 3 - unstable_karma: -3 - notes: New upstream release: 0.1.0 And that\u0026rsquo;s it, no need to access dist-git any more.\nPlease give packit a try and let us know what you think.\nPackit 0.3.0 (2019-04-11) #  In the previous post we promised to provide a new release every 2 weeks and we are already breaking this promise as it\u0026rsquo;s been 3 weeks since then. We decided to wait with the release to merge several pull requests related to source-git support.\nNow the good news. You can find a complete list of new features and improvements of version 0.3.0 in the changelog.\nFeatures #   You can now specify your own hooks or actions to replace default packit behaviour. (More information can be found in the documentation). Packit supports pagure.io-based upstream projects. Commands propose-update and sync-from-downstream supports copying directories. A new command status! It displays useful upstream/downstream info. Packit now supports Source-git. The functionality is not available, yet - we will add a CLI interface for it in the next release. You can now have a config file for packit in your home directory(~/.config/packit.yaml). Packit installed from an RPM now has manpages.  packit status example #  $ packit status Cloning repo: https://src.fedoraproject.org/rpms/packit.git -\u0026gt; /tmp/tmp84we_6n8 Downstream PRs: No open PRs. f29: 0.2.0 f30: 0.2.0 master: 0.2.0 Packit 0.4.0 \u0026amp; 0.4.1 (2019-05-18) #  It\u0026rsquo;s been over a month since we released packit \u0026ldquo;0.3.0\u0026rdquo;. Here comes packit 0.4.0 (and patch release 0.4.1) and as always they bring a lot of new features and improvements.\nYou can find a complete list in the changelog.\nPackit as a service #   We have Packit as a service running in OpenShift and also a GitHub App, which uses it. Unfortunately it\u0026rsquo;s still not in the Marketplace, so we have been the only one using it so far. The service/app submits builds in copr and once they\u0026rsquo;re done it adds a GitHub status and comment with instructions how to install the builds. The service is now configurable via jobs defined in configuration file. Packit is now able to check GPG signatures of the upstream commits against configured fingerprints.  CLI #   srpm command now works also with Source-git. status command now access remote APIs asynchronously in parallel, which should speed up the execution. CLI has new --dry-run option to not perform any remote changes (pull requests or comments). Fedmsg parsing has been unified into a single listen-to-fedmsg command.  Packit 0.4.2 (2019-06-26) #  Another relase after a month since 0.4.1, this time mostly with bug fixes.\nWe\u0026rsquo;ve been busy polishing our Github App recently, therefore we had no resources for new features.\nSee CHANGELOG for more details.\nSeptember 2020 #  Week 36 (August 31th - September 4th) #   We store the submission time of SRPM builds now (packit-service#795 by Anchit). Shreyas improved implementation of the build status reporting (packit-service#740). Anchit enhanced the /koji-builds endpoint to be more consistent with /copr-builds endpoint (packit-service#791).  Week 37 (September 7th - September 11th) #   Stage now uses Tokman to get access tokens for GitHub, which should resolve race condition when running parallel jobs (Tokman by Hunor, ogr integration by Matej). Franta has addressed problems with Testing-Farm cluster with custom response on PRs that links to more information (pinned info, packit-service#798).  Week 38 (September 14th - September 18th) #   The combination of the source-git patches with existing patches now works well (packit#963). Service now mostly supports also GitLab as you can see here or here. A lot of small issues were fixed in the last week (packit-service#806, packit-service#812, packit-service#814, packit-service#815, packit-service#816 ). Created Copr projects are now prefixed with the hostname for non-GitHub services and also support multipart namespaces (packit-service#819). Laura fixed two testing-farm related issues (packit-service#808, packit-service#809). You can now use test job also on Pagure and GitLab thanks to that.  Week 39 (September 21st - September 25th) #   Packit-service can be configured to work with private namespaces. This is plumbing work which we need right now for CentOS Stream. We are not planning to enable this for GitHub - packit-service will still work only for public repositories, private ones are ignored. packit-service#831 If git tag contains more information than just version (e.g. pkg_name-v1.2.3), it is possible to use upstream_tag_template to extract version from the tag, which will be used in a subsequent task. doc packit#959 Added support for globbing pattern in upstream_ref. doc packit#960 Packit --remote is global option now and available for all commands. Because of this sync-from-downstream --remote was renamed to --remote-to-push. Remote can now be specified in the user\u0026rsquo;s config (via upstream_git_remote parameter). packit#977  Following bugs were fixed:\n Packit dropping leading zeros in version. packit#814 Packit CLI issue caused by picking incorrect copr project name. packit#971  Week 40 (September 28th - October 2nd) #   Packit-service is now explicitly checking if requested copr-build targets exist and if not, the user is informed about it. packit-service#835 We have improved the way how packit updates %setup line in a spec file - you are now able to set content of -n option via archive_root_dir_template config option, it defaults to {upstream-pkg-name}. doc packit#834 Packit is able to generate a patch file with format-patch without leading a/ and b/ in the patch diff. Required for patches in dist-git which are applied with -p0. Contribution guidelines were updated, now we have one shared link.  Week 44-48 (November) 2019 #  With this blog post we\u0026rsquo;d like to continue with the idea of openly communicating changes in Packit. Since most of the developers use Packit as the GitHub App (which uses code from this repository - Packit Service), this blog will be about changes in all the parts, i.e. the GitHub App, the Packit Service and Packit itself.\nContinuous Deployment (CD) #  At the moment the workflow is that one of us manually triggers production container image build at the end of a week. This image is then automatically deployed into our production instance of the service over a weekend (Sun/Mon night) so that everyone can start a week with all the amazing stuff we added the previous week. In case an issue makes it through our staging instance into production uncaught, we can easily rollback on Monday. The same person also writes down what\u0026rsquo;s changed in Packit (service/app) since previous deployment.\nChanges in production (since the end of November) #  Previous post is almost half a year old so we won\u0026rsquo;t list all the changes since then, but only since last deployment, i.e. since end of December.\nPackit #  Previous deployment was running packit-0.7.1. We haven\u0026rsquo;t released a newer version since then, but in the service we install Packit from the Git repository (we have a separate stable git branch for our production deployment). From the most visible changes, Packit now:\n better handles Create-archive action is able to work in a repo with detached head logs output from subprocesses in realtime syncs config file and spec file by default in Propose-update action hadles patches with undecodable chars  Packit Service #  Now:\n better reports Copr builds  uses separate commit status for srpm build and every chroot clears test farm commit statuses when new build is triggered better handles failed Copr builds   gracefully handles no config file in the repo better handles when no (copr build) targets are specified in config file better checks whitelist of users does not create duplicate tickets in our notification repo when a new user install the app  Changes not visible to end users:\n using Requre for integration/E2E tests Fedora messaging consumer part of the service has been improved and moved to separate repo/image using FAS instead of Fedora Badges for checking whether a user is Fedora packager many improved logs many bugs squashed lot\u0026rsquo;s of code refactored  December 2019 #  Week 49 #  ogr \u0026amp; packit #   ogr-0.9.0 has been released greatly restructured. (#291) packit status (CLI) now shows also latest Copr builds. (#579) Target aliases (currently fedora-development, fedora-stable, fedora-all) can now be used in the packit config file. (#619) When doing a new update in Fedora dist-git, packit now by default creates a new pull request instead of pushing directly to dist-git. (#622)  packit service #   Does not set test checks when tests are not configured. (#275) Supports target aliases and dist-git branches aliases. (#277, #285) Nicely formats errors from OpenShift API. (#283) Runs Copr build when user adds a /packit build comment into a PR. (#290)  Week 50 #  packit #   If there is no upstream_package_name/downstream_package_name given in .packit.yaml, they now default to the name of the GitHub repo. (#624) If no jobs are defined in .packit.yaml packit by default runs build job on fedora-stable targets and propose_downstream on fedora-all branches. (#625) build command has nicer output. (#630) Smaller fixes. (#630, #636)  packit service #   Creates a new issue when propose-update fails. (#300) Better reports failed submitting of a Copr build. (#301)  "});})();